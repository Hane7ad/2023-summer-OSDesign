# 

[TOC]

# Lab1. Xv6 and Unix utilities

## 一. Boot xv6 ([easy](https://pdos.csail.mit.edu/6.828/2020/labs/guidance.html))

### 1. 实验要求

​	理解操作系统的引导启动过程，克隆课程代码仓库xv6-labs-2020，编译代码库中的源码，并通过qemu编译运行xv6系统。

### 2. 实验步骤

#### 2.1. 下载源码

git获取实验环境

```bash
$ git clone git://g.csail.mit.edu/xv6-labs-2020
$ cd xv6-labs-2020
$ git checkout util
```

文件夹中即为实验所需代码

xv6-labs-2020 代码库与配套教材的 xv6-riscv 源码略有不同，它主要添加了一些文件

#### 2.2. 启动xv6

在xv6-labs-2020目录下

```bash
make qemu
```

即可编译并运行xv6系统

xv6 通过 QEMU 模拟器启动后，启动 shell 进程，最后会看到下面的输出，说明已经成功编译并运行 xv6 系统。

```bash
xv6 kernel is booting

hart 2 starting
hart 1 starting
init: starting sh
$ 
```

#### 2.3. 测试xv6

输入`ls`命令，即创建子进程`ls`，展示xv6目录下的文件，结果如下

```bash
$ ls
.              1 1 1024
..             1 1 1024
README         2 2 2059
xargstest.sh   2 3 93
cat            2 4 24256
echo           2 5 23080
forktest       2 6 13272
grep           2 7 27560
init           2 8 23816
kill           2 9 23024
ln             2 10 22880
ls             2 11 26448
mkdir          2 12 23176
rm             2 13 23160
sh             2 14 41976
stressfs       2 15 24016
usertests      2 16 148456
grind          2 17 38144
wc             2 18 25344
zombie         2 19 22408
console        3 20 0
```

打印初始文件系统中的文件，测试成功。

#### 2.4. 其他操作

在 xv6 中按 `Ctrl + p `会显示当前系统的进程信息。

```bash
1 sleep  init
2 sleep  sh
```

在 xv6 中按 `Ctrl + a` ，然后按` x `即可退出 xv6 系统。

### 3. 注意事项与提示

在qemu中，先按`Ctrl + a`，再按x，即可退出。

## 二. sleep ([easy](https://pdos.csail.mit.edu/6.828/2020/labs/guidance.html))

### 1. 实验要求

在该实验中，我们需要实现 Unix 中经典的实用工具 sleep 。sleep 程序使得当前进程暂停一定的时钟周期数，时钟周期数由用户指定。

### 2. 实验步骤

#### 2.1. 准备源码

在user目录下创建`sleep.c`，编写代码。

#### 2.2. 编译配置

打开Makefile，在 `UPROGS` 项中最后一行添加 `$U/_sleep\`

```makefile
$U/_sleep\ 	
```

#### 2.3. 测试程序

启动xv6，进行测试

```bash
$ sleep
usage: sleep <time>
$ sleep 1 1
usage: sleep <time>
$ sleep 20
is sleeping...
$ 
```

测试命令正常。若用户输入正确的sleep命令，则系统会暂停相应时间；若用户输入不符合格式的sleep命令，则程序会提示sleep命令的正确用法。

退出xv6进行单元测试

```bash
./grade-lab-util sleep
```

单元测试通过

````bash
make: 'kernel/kernel' is up to date.
== Test sleep, no arguments == sleep, no arguments: OK (1.9s)
== Test sleep, returns == sleep, returns: OK (0.8s)
== Test sleep, makes syscall == sleep, makes syscall: OK (1.0s)
````

#### 2.4. 实验过程分析

首先引入头文件，即 `kernel/types.h` 和 `user/user.h` 

```C
#include "kernel/types.h"
#include "user/user.h"
```

进入主函数后，根据主函数参数判断用户的输入是否正确。

若参数数量不为2，则提示用户正确用法并退出

```
if(argc != 2){
        fprintf(2,"usage: sleep <time>\n");
        exit(1);
    }
```

若用户输入正确，则使系统暂停用户输入的时钟周期的时间后正确退出。

```
int second = atoi(argv[1]);
printf("is sleeping...\n");
sleep(second);
exit(0);
```

### 3. 注意事项与提示

+ 在完成代码的编写后，需要将该源文件加入到 xv6 的 Makefile 里。打开 Makefile ，找到 UPROGS 环境变量，然后按照其格式，在其后面加入一行：

    `U/_sleep\`

+ 进行单元测试时要返回到根目录进行测试

## 三. pingpong ([easy](https://pdos.csail.mit.edu/6.828/2020/labs/guidance.html)) 

### 1. 实验要求

在本实验中，需要实现一个名为 pingpong 的实用工具，在一对管道上实现两个进程之间的通信。父进程通过第一个管道给子进程发送一个信息“ping”，子进程接收父进程的信息后打印 “：<pid>: received ping”；然后子进程通过另一个管道发送一个信息 “pong” 给父进程，父进程接收子进程的信息然后打印 "<pid>: received pong" ，然后退出。

### 2. 实验步骤

#### 2.1. 准备源码

在user目录下新建`pingpong.c`，编写代码。

+ 使用`pipe`来创造管道
+ 使用`fork`创建子进程
+ 使用`read`从管道中读取数据，并且使用`write`向管道中写入数据
+ 使用`getpid`获取调用进程的pid

fork 会把父进程的寄存器（又称为上下文）、内存空间和进程控制块复制一份，用来生成子进程，并且将子进程的进程控制块中的父进程指针指向其父进程；此时父子进程几乎完全一致，为了方便程序判断自己是父还是子， fork 会给两个进程不同的返回值，父进程得到的是子进程的 pid ，而子进程的返回值则为 0。

#### 2.2. 编译配置

打开Makefile，在 `UPROGS` 项中最后一行添加 `$U/_pingpong\`

#### 2.3. 测试程序

启动xv6，输入`pingpong`命令进行测试

````bash
$ pingpong
4: received ping
3: received pong
$
````

退出xv6，进行单元测试

```bash
./grade-lab-util pingpong
```

测试通过

```bash
make: 'kernel/kernel' is up to date.
== Test pingpong == pingpong: OK (1.9s) 
```

### 3. 注意事项与提示

+ 在完成代码的编写后，需要将该源文件加入到 xv6 的 Makefile 里。打开 Makefile ，找到 UPROGS 环境变量，然后按照其格式，在其后面加入一行：

    `$U/_pingpong\`

+ 要注意子进程和父进程的需要端口部分。我们可以通过在fork前打开两个双向管道，在父子进程中分别关闭对应管道的读端和写端的方式来解决.

## 四. primes ([moderate](https://pdos.csail.mit.edu/6.828/2020/labs/guidance.html))/([hard](https://pdos.csail.mit.edu/6.828/2020/labs/guidance.html))

### 1. 实验要求

本实验需要使用管道（pipe）和进程复制（fork）来建立一个管道，实现筛选素数的并发版本。第一个进程将数字2到35输入管道中，对于每个素数，需要创建一个进程，它通过一个管道从左边的进程读取数据，并通过另一个管道向右边的进程写入数据。由于 xv6 系统的文件描述符和进程数量有限，第一个进程可以在数字35时停止。

### 2. 实验步骤

#### 2.1. 准备源码

在user目录下创建`primes.c`，编写代码。

这里我定义了两个函数，一个是mapping函数，一个是primes函数。其中，mapping函数用于文件描述符重定向，primes函数用于求素数。

```
//文件描述符重定向
void mapping(int n, int pd[])
{
  // 关闭文件描述符 n 
  close(n);
  // 将管道的 读或写 端口复制到描述符 n 上, 产生一个 n 到 pd[n] 的映射
  dup(pd[n]);
  // 关闭管道中的描述符
  close(pd[0]);
  close(pd[1]);
}

// 求素数
void primes()
{
  // 定义变量获取管道中的数
  int previous, next;
  // 定义管道描述符数组
  int fd[2];
  // 从管道读取数据
  if (read(0, &previous, sizeof(int)))
  {
    // 第一个一定是素数，直接打印
    printf("prime %d\n", previous);
    // 创建管道
    pipe(fd);
    // 创建子进程
    if (fork() == 0)
    {
      // 子进程将管道的写端口映射到描述符 1 上
      mapping(1, fd);
      // 循环读取管道中的数据
      while (read(0, &next, sizeof(int)))
      {
        // 如果该数不是管道中第一个数的倍数
        if (next % previous != 0)
        {
          // 写入管道
          write(1, &next, sizeof(int));
        }
      }
    }
    else
    {
      // 父进程
      // 等待子进程把数据全部写入管道
      wait(NULL);
      // 父进程将管道的读端口映射到描述符 0 上
      mapping(0, fd);
      // 递归执行此过程
      primes();
    }  
  }  
}
```



#### 2.2. 编译配置

打开Makefile，在 `UPROGS` 项中最后一行添加 `$U/_primes\`

```makefile
$U/_primes\ 	
```

#### 2.3. 测试程序

启动xv6，输入`primes`命令进行测试

````bash
$ primes
prime 2
prime 3
prime 5
prime 7
prime 11
prime 13
prime 17
prime 19
prime 23
prime 29
prime 31
$
````

退出xv6，进行单元测试

```bash
./grade-lab-util primes
```

测试通过

```
make: 'kernel/kernel' is up to date.
== Test primes == primes: OK (1.8s)
```

### 3. 注意事项与提示

+ 将程序添加到 Makefile 中的 UPROGS 。
+ 主进程只有在打印完所有输出后才能退出，即所有其他进程已退出后主进程才能退出。
+ 仔细关闭进程不需要的文件描述符，否则程序将在第一个进程达到35之前就会导致xv6系统资源不足。
+ 应该仅在需要时在管线中创建进程。

## 五. find ([moderate](https://pdos.csail.mit.edu/6.828/2020/labs/guidance.html))

### 1. 实验要求

编写一个简单的 UNIX `find` 程序，在目录树中查找包含特定名称的所有文件。

### 2. 实验步骤

#### 2.1. 准备源码

在user目录下创建`find.c`，编写代码。

在这里，我定义了find函数，用于递归查找目录中具有指定名称的文件。

```
void find(char *dir, char *file)
{   
    // 声明 文件名缓冲区 和 指针
    char buf[512], *p;
    // 声明文件描述符 fd
    int fd;
    // 声明与文件相关的结构体
    struct dirent de;
    struct stat st;

    // open() 函数打开路径，返回一个文件描述符，如果错误返回 -1
    if ((fd = open(dir, 0)) < 0)
    {
        // 报错，提示无法打开此路径
        fprintf(2, "find: cannot open %s\n", dir);
        return;
    }

    // int fstat(int fd, struct stat *);
    // 系统调用 fstat 与 stat 类似，但它以文件描述符作为参数
    // int stat(char *, struct stat *);
    // stat 系统调用，可以获得一个已存在文件的模式，并将此模式赋值给它的副本
    // stat 以文件名作为参数，返回文件的 i 结点中的所有信息
    // 如果出错，则返回 -1
    if (fstat(fd, &st) < 0)
    {
        // 出错则报错
        fprintf(2, "find: cannot stat %s\n", dir);
        // 关闭文件描述符 fd
        close(fd);
        return;
    }

    // 如果不是目录类型
    if (st.type != T_DIR)
    {
        // 报类型不是目录错误
        fprintf(2, "find: %s is not a directory\n", dir);
        // 关闭文件描述符 fd
        close(fd);
        return;
    }

    // 如果路径过长放不入缓冲区，则报错提示
    if(strlen(dir) + 1 + DIRSIZ + 1 > sizeof buf)
    {
        fprintf(2, "find: directory too long\n");
        // 关闭文件描述符 fd
        close(fd);
        return;
    }
    // 将 dir 指向的字符串即绝对路径复制到 buf
    strcpy(buf, dir);
    // buf 是一个绝对路径，p 是一个文件名，通过加 "/" 前缀拼接在 buf 的后面
    p = buf + strlen(buf);
    *p++ = '/';
    // 读取 fd ，如果 read 返回字节数与 de 长度相等则循环
    while (read(fd, &de, sizeof(de)) == sizeof(de))
    {
        if(de.inum == 0)
            continue;
        // strcmp(s, t);
        // 根据 s 指向的字符串小于（s<t）、等于（s==t）或大于（s>t） t 指向的字符串的不同情况
        // 分别返回负整数、0或正整数
        // 不要递归 "." 和 "..."
        if (!strcmp(de.name, ".") || !strcmp(de.name, ".."))
            continue;
        // memmove，把 de.name 信息复制 p，其中 de.name 代表文件名
        memmove(p, de.name, DIRSIZ);
        // 设置文件名结束符
        p[DIRSIZ] = 0;
        // int stat(char *, struct stat *);
        // stat 系统调用，可以获得一个已存在文件的模式，并将此模式赋值给它的副本
        // stat 以文件名作为参数，返回文件的 i 结点中的所有信息
        // 如果出错，则返回 -1
        if(stat(buf, &st) < 0)
        {
            // 出错则报错
            fprintf(2, "find: cannot stat %s\n", buf);
            continue;
        }
        // 如果是目录类型，递归查找
        if (st.type == T_DIR)
        {
            find(buf, file);
        }
        // 如果是文件类型 并且 名称与要查找的文件名相同
        else if (st.type == T_FILE && !strcmp(de.name, file))
        {
            // 打印缓冲区存放的路径
            printf("%s\n", buf);
        } 
    }
}
```



#### 2.2. 编译配置

打开Makefile，在 `UPROGS` 项中最后一行添加 `$U/_find\`

```makefile
$U/_find\ 	
```

#### 2.3. 测试程序

启动xv6，进行测试

```bash
$ find a
usage: find dirName fileName
$ find . sleep
./sleep
$ find . 114514
$
```

退出xv6进行单元测试

```bash
./grade-lab-util find
```

单元测试通过

````bash
make: 'kernel/kernel' is up to date.
== Test find, in current directory == find, in current directory: OK (1.0s)
== Test find, recursive == find, recursive: OK (0.9s)
````

#### 2.4 实验过程分析

仿照了`ls()`函数，首先声明文件名缓冲区、文件描述符和文件相关的结构体。

接着试探是否能进入给定路径，使用系统调用获得一个已存在文件的模式，并判断其类型。

如果该路径不是目录类型就报错。接着把绝对路径进行拷贝，循环获取路径下的文件名，与要查找的文件名进行比较，如果类型为文件且名称与要查找的文件名相同则输出路径，如果是目录类型则递归调用 `find()` 函数继续查找。

### 3. 注意事项与提示

* 查看 user/ls.c 了解如何读目录。
* 使用递归查找子目录下的文件
* 不要在 "." 和 ".."目录中递归 。
* 比较字符串要使用 strcmp() 函数。
* 将程序添加到 Makefile 的 UPROGS 中。

## 六. xargs ([moderate](https://pdos.csail.mit.edu/6.828/2020/labs/guidance.html))

### 1. 实验要求

编写一个简单的 UNIX `xargs` 程序，从标准输入中读取行并为每一行运行一个命令，将该行作为命令的参数提供。

### 2. 实验步骤

#### 2.1. 准备源码

在user目录下创建`xargs.c`，编写代码。

在这里，我定义了readline函数，用于读取一行输入。

```
// 读取一行输入
int readline()
{
    argnum = preargnum;     // 将命令行参数数量赋值给 argnum
    memset(arg_buf, 0, sizeof(arg_buf));    // 清空参数缓冲区
    for (;;)
    {
        n = read(0, &ch, sizeof(ch));   // 从标准输入读取一个字符
        if (n == 0)
        {
            return 0;   // 如果读取结束，返回 0
        }
        else if (n < 0)
        {
            fprintf(2, "read error\n");   // 读取错误，输出错误信息
            exit(1);
        }
        else
        {
            if (ch == '\n')
            {
                memcpy(args[argnum], arg_buf, strlen(arg_buf) + 1);    // 将参数缓冲区的内容复制到 args 数组中
                argnum++;   // 参数数量加一
                return 1;   // 返回读取成功的状态
            }
            else if (ch == ' ')
            {
                memcpy(args[argnum], arg_buf, strlen(arg_buf) + 1);    // 将参数缓冲区的内容复制到 args 数组中
                argnum++;   // 参数数量加一
                memset(arg_buf, 0, sizeof(arg_buf));   // 清空参数缓冲区
            }
            else
            {
                arg_buf[strlen(arg_buf)] = ch;   // 将读取的字符添加到参数缓冲区
            }
        }
    }
}

```



#### 2.2. 编译配置

打开Makefile，在 `UPROGS` 项中最后一行添加 `$U/_xargs\`

```makefile
$U/_xargs\ 	
```

#### 2.3. 测试程序

启动xv6，进行测试

```bash
$ echo hello too | xargs echo bye
bye hello too
$ find . b | xargs grep hello
hello
hello
hello
$ sh < xargstest.sh
$ mkdir: a failed to create
$ $ mkdir: c failed to create
$ $ $ hello
hello
hello
$ $
```

退出xv6进行单元测试

```bash
./grade-lab-util xargs
```

单元测试通过

````bash
make: 'kernel/kernel' is up to date.
== Test xargs == xargs: OK (1.7s)
````

### 3. 注意事项与提示

- 使用`fork`和`exec`对每行输入调用命令，在父进程中使用`wait`等待子进程完成命令。
- 要读取单个输入行，请一次读取一个字符，直到出现换行符（'\n'）。
- kernel/param.h声明`MAXARG`，如果需要声明`argv`数组，这可能很有用。
- 将程序添加到Makefile中的`UPROGS`。
- 对文件系统的更改会在qemu的运行过程中保持不变；要获得一个干净的文件系统，请运行`make clean`，然后`make qemu`

## 七. 总实验结果

在目录下创建`time.txt`，并输入完成实验的小时数。在终端执行

```
 ./grade-lab-util
```

来对实验结果进行完全测试。

测试结果如下：

```
make: 'kernel/kernel' is up to date.
== Test sleep, no arguments == sleep, no arguments: OK (1.4s)
== Test sleep, returns == sleep, returns: OK (0.9s)
== Test sleep, makes syscall == sleep, makes syscall: OK (1.0s)
== Test pingpong == pingpong: OK (1.1s)
== Test primes == primes: OK (1.0s)
== Test find, in current directory == find, in current directory: OK (1.1s)
== Test find, recursive == find, recursive: OK (1.1s)
== Test xargs == xargs: OK (1.0s)
== Test time ==
time: OK
Score: 100/100
```

## 八. 遇到的问题及解决方法

### 1. 单元测试失败

退出xv6，执行单元测试

```bash
./grade-lab-util sleep
```

报错 `/usr/bin/env: ‘python’: No such file or directory`

解决方法：来到/usr/bin/env目录，发现没有`python`而是`python3`。进入实验源码目录下的`./grade-lab-util`, 第一行`python`修改为`python3`

### 2. make grade

最后`make grade`报错fail，读取`time.txt`失败。

解决方法：在根目录下创建`time.txt`文件，写入数字。



# Lab2. system calls

在Lab1中，我使用系统调用编写了一些实用程序。在本实验中，我将向xv6添加一些新的系统调用，这将帮助我了解它们是如何工作的，并使我更加了解xv6内核的一些内部结构。

## 一. System call tracing ([moderate](https://pdos.csail.mit.edu/6.828/2020/labs/guidance.html))

### 1. 实验要求

添加一个系统调用跟踪功能，该功能可以在以后的实验中为你提供帮助。你将创建一个新的 `trace` 系统调用来控制跟踪。
它应该有一个参数，一个整数`mask(掩码)`，其指定要跟踪的系统调用。例如，为了跟踪 `fork` 系统调用，程序调用 `trace (1 << SYS_fork) `，其中` SYS_fork` 是来自` kernel/syscall.h `的系统调用号。
如果掩码中设置了系统调用的编号，则必须修改 xv6 内核以在每个系统调用即将返回时打印出一行。
该行应包含 进程 ID 、系统调用名称 和 返回值 ；不需要打印系统调用参数。 trace 系统调用应该为调用它的进程和它随后派生的任何子进程启用跟踪，但不应影响其他进程。

### 2. 实验步骤

#### 2.1. 编写代码并配置

+ 在`kernel/syscall.h`里为trace分配系统调用号。

    ```
    #define SYS_close  21
    #define SYS_trace  22 // NEW
    ```

+ 在`user/user.h`中将`trace`系统调用加入声明。

    ```
    int trace(int);
    ```

+ 在`user/usys.pl`中加入`trace`系统调用的入口。

    ```
    entry("trace");
    ```

+ 为了保存每个进程的` trace `的参数，我们需要在进程控制块中加入一个新的变量。查看`kernel/proc.h` ，找到进程的数据结构` struct proc` ，在其中加入一行代码：

    ```
    int mask;
    ```

+ 在` kernel/syscall.c `中的`syscalls[num]()`函数中添加`trace`系统调用。

    ```
    static uint64 (*syscalls[])(void) = {
      ...
      [SYS_trace]   sys_trace,
    };
    ```

+ 为内核态的系统调用`trace`在`kernel/syscall.c`加上声明。

    ```
    extern uint64 sys_trace(void)
    ```

+ 在`kernel/sysproc.c`中编写`sys_trace`的具体实现，将传进来的参数送给现有进程的`mask`变量。

    ```
    uint64
    sys_trace(void)
    {
      int mask;
      // 取 a0 寄存器中的值返回给 mask
      if(argint(0, &mask) < 0)
        return -1;
      
      // 把 mask 传给现有进程的 mask
      myproc()->mask = mask;
      return 0;
    }
    ```

+ 在`kernel/syscall.c`中定义系统调用名称字符串的数组，其中系统调用号从1开始。

    ```
    static char *syscall_names[] = {
      "", "fork", "exit", "wait", "pipe", 
      "read", "kill", "exec", "fstat", "chdir", 
      "dup", "getpid", "sbrk", "sleep", "uptime", 
      "open", "write", "mknod", "unlink", "link", 
      "mkdir", "close", "trace"};
    ```

+ 最后在根目录下的Makefile中，在 `UPROGS` 项中最后一行添加 `$U/_trace\`

    ```makefile
    $U/_trace\
    ```


#### 2.2. 程序测试

启动xv6，进行测试

```bash
$ trace 32 grep hello README
3: syscall read -> 1023
3: syscall read -> 966
3: syscall read -> 70
3: syscall read -> 0
$
$ trace 2147483647 grep hello README
4: syscall trace -> 0
4: syscall exec -> 3
4: syscall open -> 3
4: syscall read -> 1023
4: syscall read -> 966
4: syscall read -> 70
4: syscall read -> 0
4: syscall close -> 0
$
$ grep hello README
$
$ trace 2 usertests forkforkfork
usertests starting
6: syscall fork -> 7
test forkforkfork: 6: syscall fork -> 8
8: syscall fork -> 9
9: syscall fork -> 10
9: syscall fork -> 11
10: syscall fork -> 12
9: syscall fork -> 13
10: syscall fork -> 14
11: syscall fork -> 15
9: syscall fork -> 16
10: syscall fork -> 17
9: syscall fork -> 18
10: syscall fork -> 19
11: syscall fork -> 20
9: syscall fork -> 21
10: syscall fork -> 22
11: syscall fork -> 23
9: syscall fork -> 24
10: syscall fork -> 25
9: syscall fork -> 26
11: syscall fork -> 27
9: syscall fork -> 28
10: syscall fork -> 29
11: syscall fork -> 30
9: syscall fork -> 31
10: syscall fork -> 32
11: syscall fork -> 33
9: syscall fork -> 34
10: syscall fork -> 35
11: syscall fork -> 36
9: syscall fork -> 37
10: syscall fork -> 38
9: syscall fork -> 39
10: syscall fork -> 40
11: syscall fork -> 41
9: syscall fork -> 42
10: syscall fork -> 43
9: syscall fork -> 44
11: syscall fork -> 45
10: syscall fork -> 46
9: syscall fork -> 47
11: syscall fork -> 48
10: syscall fork -> 49
9: syscall fork -> 50
10: syscall fork -> 51
9: syscall fork -> 52
11: syscall fork -> 53
9: syscall fork -> 54
10: syscall fork -> 55
11: syscall fork -> 56
9: syscall fork -> 57
10: syscall fork -> 58
9: syscall fork -> 59
11: syscall fork -> 60
9: syscall fork -> 61
10: syscall fork -> 62
11: syscall fork -> 63
9: syscall fork -> 64
10: syscall fork -> 65
9: syscall fork -> 66
11: syscall fork -> 67
10: syscall fork -> 68
9: syscall fork -> -1
10: syscall fork -> -1
11: syscall fork -> -1
12: syscall fork -> -1
OK
6: syscall fork -> 69
ALL TESTS PASSED
$
```

退出xv6进行单元测试

```bash
./grade-lab-syscall trace
```

单元测试通过

````bash
make: 'kernel/kernel' is up to date.
== Test trace 32 grep == trace 32 grep: OK (1.6s)
== Test trace all grep == trace all grep: OK (0.8s)
== Test trace nothing == trace nothing: OK (1.0s)
== Test trace children == trace children: OK (9.7s)
````

### 3. 注意事项与提示

+ 将 `$U/_trace `添加到 `Makefile` 的` UPROGS` 中
+ 运行 `make qemu` ， 你将看到编译器无法编译` user/trace.c `，因为系统调用的用户空间存根还不存在：将系统调用的原型添加到 `user/user.h` ，将存根添加到` user/usys.pl `，以及将系统调用号添加到` kernel/syscall.h `中。 `Makefile` 调用 perl 脚本 `user/usys.pl` ，它生成 `user/usys.S `，实际的系统调用存根，它使用` RISC-V ecall` 指令转换到内核。修复编译问题后，运行` trace 32 grep hello README` ；它会失败，因为你还没有在内核中实现系统调用。
+ 在` kernel/sysproc.c `中添加一个 `sys_trace() `函数，该函数通过在` proc `结构中的新变量中记住其参数来实现新系统调用(请参阅 `kernel/proc.h` )。从用户空间检索系统调用参数的函数位于 `kernel/syscall.c` 中，你可以在` kernel/sysproc.c `中查看它们的使用示例。
+ 修改` fork() `(参见` kernel/proc.c `)以将跟踪的掩码从父进程复制到子进程。
+ 修改` kernel/syscall.c `中的` syscall() `函数以打印跟踪输出。你将需要添加要索引的系统调用名称数组.

## 二. Sysinfo ([moderate](https://pdos.csail.mit.edu/6.828/2020/labs/guidance.html))

### 1. 实验要求

在这个实验中，需要将添加一个名为 `sysinfo `的系统调用，用于收集有关正在运行的系统的信息。这个系统调用接受一个参数：一个指向` struct sysinfo `的指针（参见 `kernel/sysinfo.h `）。内核应该填充这个结构的字段：` freemem `字段应该设置为空闲内存的字节数，` nproc `字段应该设置为状态不是 `UNUSED `的进程数量。

### 2. 实验步骤

#### 2.1. 编写代码并配置

+ 在`kernel/syscall.h`里为`sysinfo`分配系统调用号。

    ```
    #define SYS_trace  22 // NEW
    #define SYS_sysinfo 23 //NEW
    ```

+ 在`user/user.h`中声明`struct sysinfo`

    ```
    struct sysinfo;
    // system calls
    // ...
    int sysinfo(struct sysinfo *);
    ```

+ 在`user/usys.pl`中加入`sysinfo`系统调用的入口。

    ```
    entry("sysinfo");
    ```

+ 在` kernel/syscall.c `中的`syscalls[num]()`函数中添加`sysinfo`系统调用。

    ```
    static uint64 (*syscalls[])(void) = {
      ...
      [SYS_sysinfo]   sys_sysinfo,
    };
    ```

+ 为内核态的系统调用`sysinfo`在`kernel/syscall.c`加上声明。

    ```
    extern uint64 sys_sysinfo(void)
    ```

+ 由于在上一个实验中新增了`syscall_names`数组以记录各个系统调用的名字，所以需要在`syscall_names`数组中新增`sysinfo`这个名字。

    ```
    static char *syscall_names[] = {
      "", "fork", "exit", "wait", "pipe", 
      "read", "kill", "exec", "fstat", "chdir", 
      "dup", "getpid", "sbrk", "sleep", "uptime", 
      "open", "write", "mknod", "unlink", "link", 
      "mkdir", "close", "trace", "sysinfo"};
    ```

+ 在`kernel/proc.c`中新增函数`nproc`，获取当前可用的进程数目

    ```
    //返回当前可用的进程数目
    uint64
    nproc(void)
    {
      struct proc *p;
      // num计数
      uint64 num = 0;
      // 遍历所有进程
      for (p = proc; p < &proc[NPROC]; p++)
      {
        //加锁
        acquire(&p->lock);
        // 进程的状态state不是UNUSED，则计数+1
        if (p->state != UNUSED)
        {
          num++;
        }
        // 解锁
        release(&p->lock);
      }
      return num;
    }
    
    ```

+ 在`kernel/kalloc.c`中新增函数`free_mem`，函数返回当前空闲的内存空间大小

    ```
    // 返回当前空闲的内存空间大小
    uint64
    free_mem(void)
    {
      struct run *p;
      // num空闲页面计数
      uint64 num = 0;
      // 加锁
      acquire(&kmem.lock);
      //p指向freelistr
      p = kmem.freelist;
      // p非空，遍历整条链表
      while (p)
      {
        //计数+1
        num++;assd
        p = p->next;
      }
      // 解锁
      release(&kmem.lock);
      // 页面数量*4096 byte
      return num * PGSIZE;
    }
    ```

+ 在`kernel/defs.h`中添加这两个新函数的声明

    ```
    // kalloc.c
    ...
    uint64          free_mem(void);
    
    // proc.c
    ...
    uint64          nproc(void);
    ```

+ 仿照`kernel/sysfile.c`下的`sys_fstat()`函数并参考`copyout()`函数的定义，在`kernel/sysproc.c`添加`sys_sysinfo`的函数实现

    ```
    // kernel/sysproc.c
    //新增头文件
    #include "sysinfo.h"
    
    uint64
    sys_sysinfo(void)
    {
      // 虚地址，指向一个sysinfo
      uint64 addr;
      struct sysinfo info;
      struct proc *p = myproc();
      
      if (argaddr(0, &addr) < 0)
    	  return -1;
      // 获取空闲内存数量
      info.freemem = free_mem();
      // 获取可用进程数量
      info.nproc = nproc();
      //拷贝
      if (copyout(p->pagetable, addr, (char *)&info, sizeof(info)) < 0)
        return -1;
      
      return 0;
    }
    
    ```

+ 在`user`目录下新增一个`sysinfotest.c`的用户程序

    ```
    #include "kernel/types.h"
    #include "kernel/riscv.h"
    #include "kernel/sysinfo.h"
    #include "user/user.h"
    
    
    void
    sinfo(struct sysinfo *info) {
      if (sysinfo(info) < 0) {
        printf("FAIL: sysinfo failed");
        exit(1);
      }
    }
    
    //
    // use sbrk() to count how many free physical memory pages there are.
    //
    int
    countfree()
    {
      uint64 sz0 = (uint64)sbrk(0);
      struct sysinfo info;
      int n = 0;
    
      while(1){
        if((uint64)sbrk(PGSIZE) == 0xffffffffffffffff){
          break;
        }
        n += PGSIZE;
      }
      sinfo(&info);
      if (info.freemem != 0) {
        printf("FAIL: there is no free mem, but sysinfo.freemem=%d\n",
          info.freemem);
        exit(1);
      }
      sbrk(-((uint64)sbrk(0) - sz0));
      return n;
    }
    
    void
    testmem() {
      struct sysinfo info;
      uint64 n = countfree();
      
      sinfo(&info);
    
      if (info.freemem!= n) {
        printf("FAIL: free mem %d (bytes) instead of %d\n", info.freemem, n);
        exit(1);
      }
      
      if((uint64)sbrk(PGSIZE) == 0xffffffffffffffff){
        printf("sbrk failed");
        exit(1);
      }
    
      sinfo(&info);
        
      if (info.freemem != n-PGSIZE) {
        printf("FAIL: free mem %d (bytes) instead of %d\n", n-PGSIZE, info.freemem);
        exit(1);
      }
      
      if((uint64)sbrk(-PGSIZE) == 0xffffffffffffffff){
        printf("sbrk failed");
        exit(1);
      }
    
      sinfo(&info);
        
      if (info.freemem != n) {
        printf("FAIL: free mem %d (bytes) instead of %d\n", n, info.freemem);
        exit(1);
      }
    }
    
    void
    testcall() {
      struct sysinfo info;
      
      if (sysinfo(&info) < 0) {
        printf("FAIL: sysinfo failed\n");
        exit(1);
      }
    
      if (sysinfo((struct sysinfo *) 0xeaeb0b5b00002f5e) !=  0xffffffffffffffff) {
        printf("FAIL: sysinfo succeeded with bad argument\n");
        exit(1);
      }
    }
    
    void testproc() {
      struct sysinfo info;
      uint64 nproc;
      int status;
      int pid;
      
      sinfo(&info);
      nproc = info.nproc;
    
      pid = fork();
      if(pid < 0){
        printf("sysinfotest: fork failed\n");
        exit(1);
      }
      if(pid == 0){
        sinfo(&info);
        if(info.nproc != nproc+1) {
          printf("sysinfotest: FAIL nproc is %d instead of %d\n", info.nproc, nproc+1);
          exit(1);
        }
        exit(0);
      }
      wait(&status);
      sinfo(&info);
      if(info.nproc != nproc) {
          printf("sysinfotest: FAIL nproc is %d instead of %d\n", info.nproc, nproc);
          exit(1);
      }
    }
    
    int
    main(int argc, char *argv[])
    {
      printf("sysinfotest: start\n");
      testcall();
      testmem();
      testproc();
      printf("sysinfotest: OK\n");
      exit(0);
    }
    ```

+ 在在`user`目录下新增一个`sysinfo.c`的用户程序

    ```
    #include "kernel/param.h"
    #include "kernel/types.h"
    #include "kernel/sysinfo.h"
    #include "user/user.h"
    
    int
    main(int argc, char *argv[])
    {
        // 参数个数非法
        if (argc != 1)
        {
            //报错
            fprintf(2, "Usage: %s need not param\n", argv[0]);
            exit(1);
        }
    
        struct sysinfo info;
        sysinfo(&info);
        // 打印系统信息
        printf("free space: %d\nused process: %d\n", info.freemem, info.nproc);
        exit(0);
    }
    ```

+ 最后在根目录下的Makefile中，在 `UPROGS` 项中添加 相应配置

    ```makefile
    $U/_sysinfo\
    $U/_sysinfotest\
    ```

#### 2.2. 程序测试

启动xv6，进行测试

```bash
$ sysinfo
free space: 133386240
used process: 3
$ sysinfotest
sysinfotest: start
sysinfotest: OK
$
```

退出xv6进行单元测试

```bash
./grade-lab-syscall sysinfo
```

单元测试通过

````bash
make: 'kernel/kernel' is up to date.
== Test sysinfotest == sysinfotest: OK (2.7s)
````

### 3. 注意事项与提示

+ 将 `$U/_sysinfotest` 添加到` Makefile `的 `UPROGS` 中。

+ 运行 `make qemu `， 你将看到编译器无法编译 `user/sysinfotest.c `。添加系统调用 `sysinfo `，按照与之前实验相同的步骤。要在 `user/user.h` 中声明` sysinfo() `的原型，需要预先声明 `struct sysinfo `：

    ```
    struct sysinfo;
    int sysinfo(struct sysinfo *);
    ```

* 修复编译问题后，运行 `sysinfotest `会失败，因为你还没有在内核中实现系统调用。
* `sysinfo `需要复制一个 `struct sysinfo `返回用户空间；有关如何使用 `copyout() `执行此操作的示例，请参阅` sys_fstat() ( kernel/sysfile.c ) `和` filestat() ( kernel/file.c )`。
* 要收集空闲内存量，请在` kernel/kalloc.c `中添加一个函数。
* 要收集进程数，请在` kernel/proc.c `中添加一个函数。

## 三. 总实验结果

在目录下创建`time.txt`，并输入完成实验的小时数。在终端执行

```
 ./grade-lab-syscall
```

来对实验结果进行完全测试。

测试结果如下：

```
make: 'kernel/kernel' is up to date.
== Test trace 32 grep == trace 32 grep: OK (1.7s)
== Test trace all grep == trace all grep: OK (0.9s)
== Test trace nothing == trace nothing: OK (0.9s)
== Test trace children == trace children: OK (10.1s)
== Test sysinfotest == sysinfotest: OK (1.9s)
== Test time ==
time: OK
Score: 35/35
```

## 四. 遇到的问题及解决方法

### 1. 忘记切换分支

退出xv6，执行单元测试

```bash
./grade-lab-util trace
```

报错 `-bash: ./grade-lab-util: No such file or directory`

解决方法：切换分支为syscall

### 2. 单元测试失败

退出xv6，执行单元测试

```bash
./grade-lab-syscall trace
```

报错 `/usr/bin/env: ‘python’: No such file or directory`

解决方法：来到/usr/bin/env目录，发现没有`python`而是`python3`。进入实验源码目录下的`./grade-lab-syscall`, 第一行`python`修改为`python3`



# Lab3. Page tables

## 一. Print a page table ([easy](https://pdos.csail.mit.edu/6.828/2020/labs/guidance.html))

### 1. 实验要求

为了帮助了解RISC-V页表，也为了帮助将来的调试，第一个任务是编写一个打印页表内容的函数。

### 2. 实验步骤

#### 2.1. 编写代码并配置

+ 在`kernel/defs.h`添加函数定义

    ````C
    void            vmprint(pagetable_t);
    ````

+ 在`kernel/exec.c`新增对`vmprint()`的调用

    ```
    if(p->pid==1)
        vmprint(p->pagetable);
    return argc;
    ```

+ 参考`kernel/vm.c`中`freewalk()`的实现，并查看`kernel/riscv.h`进程的宏定义。在`kernel/vm.c`添加`vmprint`的递归函数实现。

    ```
    //New code
    void _vmprint(pagetable_t pagetable, int level) {
        //一个页表有512项
      for (int i = 0; i < 512; i++) {
        pte_t pte = pagetable[i];
    	if (pte & PTE_V) {//有效
          uint64 pa = PTE2PA(pte);
           //打印层级关系
          for (int j = 0; j < level; j++) {
    		if (j) printf(" ");
    		printf("..");
    	  }
    	  printf("%d: pte %p pa %p\n", i, pte, pa);
             // 不是叶子页表，也就是第一或第二级页表
    	  if ((pte & (PTE_R | PTE_W | PTE_X)) == 0) {
    	    //递归打印
              _vmprint((pagetable_t)pa, level+1);
    	  }
    	}
      }
    }
    void vmprint(pagetable_t pagetable) {
        //第一行输出
      printf("page table %p\n", pagetable);
      //调用递归
      _vmprint(pagetable, 1);
    }
    ```

    上述代码中，`_vmprint`是递归函数，`level`传入层级来根据层级数量输出".."，`vmprint`是真正的输出函数，通过调用递归函数`_vmprinte`实现。

#### 2.2. 程序测试

启动xv6,自动打印第一个进程信息

```
xv6 kernel is booting

hart 2 starting
hart 1 starting
page table 0x0000000087f6e000
..0: pte 0x0000000021fda801 pa 0x0000000087f6a000
.. ..0: pte 0x0000000021fda401 pa 0x0000000087f69000
.. .. ..0: pte 0x0000000021fdac1f pa 0x0000000087f6b000
.. .. ..1: pte 0x0000000021fda00f pa 0x0000000087f68000
.. .. ..2: pte 0x0000000021fd9c1f pa 0x0000000087f67000
..255: pte 0x0000000021fdb401 pa 0x0000000087f6d000
.. ..511: pte 0x0000000021fdb001 pa 0x0000000087f6c000
.. .. ..510: pte 0x0000000021fdd807 pa 0x0000000087f76000
.. .. ..511: pte 0x0000000020001c0b pa 0x0000000080007000
init: starting sh
$
```

退出xv6进行单元测试

```bash
./grade-lab-pgtbl pte print
```

单元测试通过

```
make: 'kernel/kernel' is up to date.
== Test pte printout == pte printout: OK (1.4s)
```

### 3. 注意事项与提示

- 你可以把`vmprint()`放在`kernel/vm.c`中。
- 使用文件`kernel/riscv.h`末尾的宏。
- 函数`freewalk`可以启发你。
- 在`kernel/defs.h`中定义`vmprint`的原型，以便你可以从`exec.c`中调用它。
- 在你的`printf`调用中使用`%p`来打印出完整的 64 位十六进制 PTE 和地址，如例子中所示。

## 二. A kernel page table per process ([hard](https://pdos.csail.mit.edu/6.828/2020/labs/guidance.html))

### 1. 实验要求

xv6 有一个单一的内核页表，每当它在内核中执行时都会用到。内核页表是对物理地址的直接映射，因此内核虚拟地址`x`映射到物理地址`x`。xv6 也有一个单独的页表，用于每个进程的用户地址空间，只包含该进程用户内存的映射，从虚拟地址`0`开始。因为内核页表不包含这些映射，用户地址在内核中是无效的。因此，当内核需要使用在系统调用中传递的用户指针（例如，传递给`write()`的缓冲区指针）时，内核必须首先将该指针转换为物理地址。本节和下一节的目标是允许内核直接解除对用户指针的引用。

你的第一项工作是修改内核，使每个进程在内核中执行时使用自己的内核页表副本。

### 2. 实验步骤

#### 2.1. 编写代码并配置

+ 为`struct proc`加入内核页表,在 `kernel/proc.h` 中的 `proc` 结构体中添加一个字段 `pagetable_t kpagetable;`，表示内核态页表。

    ```
     pagetable_t pagetable;       // User page table
     pagetable_t kpagetable;      //新增内核态页表
    ```

+ 初始化内核态页表

    参考`kernel/vm.c`的`kvminit()`函数，其中已经有的`kvmmap`函数为`kpagetable`添加了映射。在`kernel/vm.c`中仿照已有的`kvmmap`函数，新增`uvmmap()`函数为上述的内核态页表添加映射，

    ```
    void uvmmap(pagetable_t pagetable, uint64 va, uint64 pa, uint64 sz, int perm) {
        if(mappages(pagetable, va, sz, pa, perm) != 0) {
            panic("uvmmap");
        }
    }
    
    pagetable_t proc_kpagetable(struct proc *p) {
        // 创建空页表
        pagetable_t kpagetable = uvmcreate();
        if(kpagetable == 0){
            return 0;
        }
    
        uvmmap(kpagetable, UART0, UART0, PGSIZE, PTE_R | PTE_W);
        uvmmap(kpagetable, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);
        uvmmap(kpagetable, CLINT, CLINT, 0x10000, PTE_R | PTE_W);
        uvmmap(kpagetable, PLIC, PLIC, 0x400000, PTE_R | PTE_W);
        uvmmap(kpagetable, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);
        uvmmap(kpagetable, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);
        uvmmap(kpagetable, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);    // 注意va为TRAMPOLINE
    
        return kpagetable;
    }
    
    
    ```

+ 在 `kernel/proc.c` 中的 `allocproc` 里调用上述函数

    ```
    static struct proc*
    allocproc(void)
    {
      //...
      // An empty user page table.
      p->pagetable = proc_pagetable(p);
      if(p->pagetable == 0){
        freeproc(p);
        release(&p->lock);
        return 0;
      }
      // 调用
      p->kpagetable = proc_kpagetable(p);
      if (p->kpagetable == 0) {
        freeproc(p);
        release(&p->lock);
        return 0;
      }  
      //...
    }
    
    ```
    
+ 为进程的内核页表添加内核栈的映射

    提示要求在每个内核页表中都添加一个对自己内核栈的映射。未修改前，内核栈初始化在`kernel/proc.c`的`procinit`函数中。我们需要删除`proinit()`中的为所有进程分配内核栈的代码，将其移到`allocproc()`中。

    ```
    // initialize the proc table at boot time.
    void
    procinit(void)
    {
      struct proc *p;
      
      initlock(&pid_lock, "nextpid");
      for(p = proc; p < &proc[NPROC]; p++) {
          initlock(&p->lock, "proc");
    
          // Allocate a page for the process's kernel stack.
          // Map it high in memory, followed by an invalid
          // guard page.
          // char *pa = kalloc();
          // if(pa == 0)
          //   panic("kalloc");
          // uint64 va = KSTACK((int) (p - proc));
          // kvmmap(va, (uint64)pa, PGSIZE, PTE_R | PTE_W);
          // p->kstack = va;
      }
      kvminithart();
    }
    ```

    内核栈的初始化原本是在 `kernel/proc.c` 中的 `procinit` 函数内完成的。实验要求将该过程转移到`allocproc` 函数内，那么就在 `kernel/proc.c` 中的 `allocproc` 修改处，添加初始化内核栈的代码

    ```
    // Look in the process table for an UNUSED proc.
    // If found, initialize state required to run in the kernel,
    // and return with p->lock held.
    // If there are no free procs, or a memory allocation fails, return 0.
    static struct proc*
    allocproc(void)
    {
      struct proc *p;
    
      for(p = proc; p < &proc[NPROC]; p++) {
        acquire(&p->lock);
        if(p->state == UNUSED) {
          goto found;
        } else {
          release(&p->lock);
        }
      }
      return 0;
    
    found:
      p->pid = allocpid();
    
      // Allocate a trapframe page.
      if((p->trapframe = (struct trapframe *)kalloc()) == 0){
        release(&p->lock);
        return 0;
      }
    
      // An empty user page table.
      p->pagetable = proc_pagetable(p);
      if(p->pagetable == 0){
        freeproc(p);
        release(&p->lock);
        return 0;
      }
    
      // process's kernel page table - lab3-2
      p->kpagetable = proc_kpagetable(p);
      if (p->kpagetable == 0) {
        freeproc(p);
        release(&p->lock);
        return 0;
      }
      // Allocate a page for the process's kernel stack. - lab3-2
      char *pa = kalloc();    // 分配页面
      if(pa == 0) {
        panic("kalloc");
      }
      uint64 va = KSTACK(0);
      // 进行虚拟地址和物理地址的映射
      uvmmap(p->kpagetable,va, (uint64)pa,PGSIZE,PTE_R | PTE_W);
      p->kstack = va;
    
      // Set up new context to start executing at forkret,
      // which returns to user space.
      memset(&p->context, 0, sizeof(p->context));
      p->context.ra = (uint64)forkret;
      p->context.sp = p->kstack + PGSIZE;
      return p;
    }
    
    ```

    

+ 每当进程调度，切换内核页

    `SATP`寄存器负责管理内核页面，可在 `kernel/proc.c` 的 `scheduler` 函数进行` SATP` 寄存器的切换。参考`kvminithart`函数，修改`proc.c`里的`scheduler`函数，在进程进行切换的时候把自己的内核页表放入到`STAP`寄存器里，让内核使用该进程的页表转换地址，如果没有进程在运行，就使用内核自己的内核页表。

    ```
    
     if(p->state == RUNNABLE) {
            // Switch to chosen process.  It is the process's job
            // to release its lock and then reacquire it
            // before jumping back to us.
            p->state = RUNNING;
            c->proc = p;
            // load the process's kernel page table - lab3-2
            w_satp(MAKE_SATP(p->kpagetable));// 切换到即将运行的进程内核页表
    		// flush TLB，刷新TLB快表
            sfence_vma();
            swtch(&c->context, &p->context); // 进程运行
    
            c->proc = 0;
    
            found = 1;
          }
          release(&p->lock);
        }
        if(found == 0) {
            kvminithart();// 进程运行完返回。no process running，切换回全局内核页表
        }
    
    ```
    
+ 释放内核栈和内核页表

    进程销毁部分添加对内核页表的释放，由于之前将`kernel stack`的初始化移入了`allocproc`函数中，所以先要对`kernel stack`进行查找释放，然后需要释放用户进程的内核页表。

    ```
    // free a proc structure and the data hanging from it,
    // including user pages.
    // p->lock must be held.
    static void
    freeproc(struct proc *p)
    {
      if(p->trapframe)
        kfree((void*)p->trapframe);
      p->trapframe = 0;
      if(p->pagetable)
        proc_freepagetable(p->pagetable, p->sz);
      p->pagetable = 0;
      p->sz = 0;
      p->pid = 0;
      p->parent = 0;
      p->name[0] = 0;
      p->chan = 0;
      p->killed = 0;
      p->xstate = 0;
      // free kernel stack - lab3-2
      if(p->kstack) {
        uvmunmap(p->kpagetable, p->kstack, 1, 1);
      }
      p->kstack = 0;
      // free kernel page table without freeing physical memory - lab3-2
      if(p->kpagetable){
        proc_freekpagetable(p->kpagetable);
      }
      p->kpagetable=0;
      p->state = UNUSED;
    }
    ```

+ 需要保证释放页表的时候而无需同时释放叶节点的物理内存页，所以需要添加一个`proc_freekpagetable`来特殊处理内存页表的释放。

    ```
    //递归释放1，2级页表
    void 
    proc_freekpagetable(pagetable_t kpagetable) {
        uvmunmap(kpagetable, UART0, 1, 0);
        uvmunmap(kpagetable, VIRTIO0, 1, 0);
        uvmunmap(kpagetable, CLINT, 0x10000 / PGSIZE, 0);
        uvmunmap(kpagetable, PLIC, 0x400000 / PGSIZE, 0);
        uvmunmap(kpagetable, KERNBASE, (PHYSTOP - KERNBASE) / PGSIZE, 0);
        uvmunmap(kpagetable, TRAMPOLINE, 1, 0);
        uvmfree(kpagetable, 0);
    }
    ```
    
+ 最后，`make qemu`后会发现有一处报错，原因是 virtio 磁盘驱动 `virtio_disk.c` 中调用了 `kvmpa()` 用于将虚拟地址转换为物理地址,此时需要换位当前进程的内核页表。将 `kvmpa()` 的参数增加一个 `pagetable_t`, 在 `kernel/virtio_disk.c` 的 `virtio_disk_rw()` 调用时传入 `myproc()->kpagetable`.

#### 2.2. 程序测试

启动xv6，输入命令

```bash
$ usertests
```

测试命令正常

```
$ usertests
usertests starting
test execout: OK
test copyin: OK
test copyout: OK
test copyinstr1: OK
test copyinstr2: OK
test copyinstr3: OK
test truncate1: OK
test truncate2: OK
test truncate3: OK
test reparent2: OK
test pgbug: OK
test sbrkbugs: usertrap(): unexpected scause 0x000000000000000c pid=3234
            sepc=0x0000000000005406 stval=0x0000000000005406
usertrap(): unexpected scause 0x000000000000000c pid=3235
            sepc=0x0000000000005406 stval=0x0000000000005406
OK
test badarg: OK
test reparent: OK
test twochildren: OK
test forkfork: OK
test forkforkfork: OK
test argptest: OK
test createdelete: OK
test linkunlink: OK
test linktest: OK
test unlinkread: OK
test concreate: OK
test subdir: OK
test fourfiles: OK
test sharedfd: OK
test exectest: OK
test bigargtest: OK
test bigwrite: OK
test bsstest: OK
test sbrkbasic: OK
test sbrkmuch: OK
test kernmem: usertrap(): unexpected scause 0x000000000000000d pid=6214
            sepc=0x000000000000201a stval=0x0000000080000000
usertrap(): unexpected scause 0x000000000000000d pid=6215
            sepc=0x000000000000201a stval=0x000000008000c350
usertrap(): unexpected scause 0x000000000000000d pid=6216
            sepc=0x000000000000201a stval=0x00000000800186a0
usertrap(): unexpected scause 0x000000000000000d pid=6217
            sepc=0x000000000000201a stval=0x00000000800249f0
usertrap(): unexpected scause 0x000000000000000d pid=6218
            sepc=0x000000000000201a stval=0x0000000080030d40
usertrap(): unexpected scause 0x000000000000000d pid=6219
            sepc=0x000000000000201a stval=0x000000008003d090
usertrap(): unexpected scause 0x000000000000000d pid=6220
            sepc=0x000000000000201a stval=0x00000000800493e0
usertrap(): unexpected scause 0x000000000000000d pid=6221
            sepc=0x000000000000201a stval=0x0000000080055730
usertrap(): unexpected scause 0x000000000000000d pid=6222
            sepc=0x000000000000201a stval=0x0000000080061a80
usertrap(): unexpected scause 0x000000000000000d pid=6223
            sepc=0x000000000000201a stval=0x000000008006ddd0
usertrap(): unexpected scause 0x000000000000000d pid=6224
            sepc=0x000000000000201a stval=0x000000008007a120
usertrap(): unexpected scause 0x000000000000000d pid=6225
            sepc=0x000000000000201a stval=0x0000000080086470
usertrap(): unexpected scause 0x000000000000000d pid=6226
            sepc=0x000000000000201a stval=0x00000000800927c0
usertrap(): unexpected scause 0x000000000000000d pid=6227
            sepc=0x000000000000201a stval=0x000000008009eb10
usertrap(): unexpected scause 0x000000000000000d pid=6228
            sepc=0x000000000000201a stval=0x00000000800aae60
usertrap(): unexpected scause 0x000000000000000d pid=6229
            sepc=0x000000000000201a stval=0x00000000800b71b0
usertrap(): unexpected scause 0x000000000000000d pid=6230
            sepc=0x000000000000201a stval=0x00000000800c3500
usertrap(): unexpected scause 0x000000000000000d pid=6231
            sepc=0x000000000000201a stval=0x00000000800cf850
usertrap(): unexpected scause 0x000000000000000d pid=6232
            sepc=0x000000000000201a stval=0x00000000800dbba0
usertrap(): unexpected scause 0x000000000000000d pid=6233
            sepc=0x000000000000201a stval=0x00000000800e7ef0
usertrap(): unexpected scause 0x000000000000000d pid=6234
            sepc=0x000000000000201a stval=0x00000000800f4240
usertrap(): unexpected scause 0x000000000000000d pid=6235
            sepc=0x000000000000201a stval=0x0000000080100590
usertrap(): unexpected scause 0x000000000000000d pid=6236
            sepc=0x000000000000201a stval=0x000000008010c8e0
usertrap(): unexpected scause 0x000000000000000d pid=6237
            sepc=0x000000000000201a stval=0x0000000080118c30
usertrap(): unexpected scause 0x000000000000000d pid=6238
            sepc=0x000000000000201a stval=0x0000000080124f80
usertrap(): unexpected scause 0x000000000000000d pid=6239
            sepc=0x000000000000201a stval=0x00000000801312d0
usertrap(): unexpected scause 0x000000000000000d pid=6240
            sepc=0x000000000000201a stval=0x000000008013d620
usertrap(): unexpected scause 0x000000000000000d pid=6241
            sepc=0x000000000000201a stval=0x0000000080149970
usertrap(): unexpected scause 0x000000000000000d pid=6242
            sepc=0x000000000000201a stval=0x0000000080155cc0
usertrap(): unexpected scause 0x000000000000000d pid=6243
            sepc=0x000000000000201a stval=0x0000000080162010
usertrap(): unexpected scause 0x000000000000000d pid=6244
            sepc=0x000000000000201a stval=0x000000008016e360
usertrap(): unexpected scause 0x000000000000000d pid=6245
            sepc=0x000000000000201a stval=0x000000008017a6b0
usertrap(): unexpected scause 0x000000000000000d pid=6246
            sepc=0x000000000000201a stval=0x0000000080186a00
usertrap(): unexpected scause 0x000000000000000d pid=6247
            sepc=0x000000000000201a stval=0x0000000080192d50
usertrap(): unexpected scause 0x000000000000000d pid=6248
            sepc=0x000000000000201a stval=0x000000008019f0a0
usertrap(): unexpected scause 0x000000000000000d pid=6249
            sepc=0x000000000000201a stval=0x00000000801ab3f0
usertrap(): unexpected scause 0x000000000000000d pid=6250
            sepc=0x000000000000201a stval=0x00000000801b7740
usertrap(): unexpected scause 0x000000000000000d pid=6251
            sepc=0x000000000000201a stval=0x00000000801c3a90
usertrap(): unexpected scause 0x000000000000000d pid=6252
            sepc=0x000000000000201a stval=0x00000000801cfde0
usertrap(): unexpected scause 0x000000000000000d pid=6253
            sepc=0x000000000000201a stval=0x00000000801dc130
OK
test sbrkfail: usertrap(): unexpected scause 0x000000000000000d pid=6265
            sepc=0x0000000000003e7a stval=0x0000000000012000
OK
test sbrkarg: OK
test validatetest: OK
test stacktest: usertrap(): unexpected scause 0x000000000000000d pid=6269
            sepc=0x0000000000002188 stval=0x000000000000fbc0
OK
test opentest: OK
test writetest: OK
test writebig: OK
test createtest: OK
test openiput: OK
test exitiput: OK
test iput: OK
test mem: OK
test pipe1: OK
test preempt: kill... wait... OK
test exitwait: OK
test rmdot: OK
test fourteen: OK
test bigfile: OK
test dirfile: OK
test iref: OK
test forktest: OK
test bigdir: OK
ALL TESTS PASSED
$
```

### 3. 注意事项与提示

- 在`proc`结构中增加一个字段，用于进程的内核页表。
- 为新进程生成内核页表的一个合理方法是实现一个修改版的`kvminit`，它可以生成一个新的页表而不是修改`kernel_pagetable`。你要从`allocproc`中调用这个函数。
- 确保每个进程的内核页表都有一个针对该进程的内核堆栈的映射。在未修改的 xv6 中，所有的内核堆栈都设置在`procinit`中。你需要将部分或全部功能转移到`allocproc`。
- 修改`scheduler()`，将进程的内核页表加载到内核的`satp`寄存器中（见`kvminithart`的启发）。不要忘记在调用`w_satp()`后调用`sfence_vma()`。
    -`scheduler()`应该在没有进程运行时使用`kernel_pagetable`。
- 在`freeproc`中释放一个进程的内核页表。
- 你需要一种方法来释放一个页表，而不需要释放物理内存页。
    -`vmprint`可能在调试页表时很有用。
- 修改 xv6 函数或添加新的函数是可以的；你可能至少需要在`kernel/vm.c`和`kernel/proc.c`中这样做（但是，不要修改`kernel/vmcopyin.c`、`kernel/stats.c`、`user/usertests.c`和`user/stats.c`）。
- 一个缺失的页表映射将可能导致内核遇到一个页故障。它将打印一个包括`sepc=0x00000000XXXXXX`的错误。你可以通过搜索`kernel/kernel.asm`中的`XXXXXXX`来找出故障发生的位置。

## 三. Simplify `copyin/copyinstr` ([hard](https://pdos.csail.mit.edu/6.828/2020/labs/guidance.html))

### 1. 实验要求

在未修改的xv6内核中的`copyin`函数通过将用户指针翻译成物理地址来从用户指针读取内存。主要是通过软件遍历进程的页表来实现这个翻译过程。

这个实验的工作就是为进程的内核页表添加用户地址空间映射，让`copyin` 可以直接解引用用户指针。

### 2. 实验步骤

#### 2.1. 编写代码并配置

+ 在`def.h`添加`vmcopyin.c`中`copyin_new()`和`copyinstr_new()`的声明

    ```
    //vmcopyin.c
    int             copyin_new(pagetable_t,char *,uint64,uint64);
    int             copyinstr_new(pagetable_t,char *,uint64,uint64);
    ```

+ 在`vm.c`中替换`copyin`和`copyinstr`函数

    ```
    int
    copyin(pagetable_t pagetable, char *dst, uint64 srcva, uint64 len)
    {
      return copyin_new(pagetable,dst,srcva,len);
    }
    int
    copyinstr(pagetable_t pagetable, char *dst, uint64 srcva, uint64 max)
    {
      return copyinstr_new(pagetable,dst,srcva,max);
    }
    ```

+ 在`vm.c`添加`vmcopypage()`函数。它将进程中用户页表复制到内核页表中，首先写一个通用函数,在`kernel/vm.c`里。只拷贝所存储的物理地址，即共享同一片物理地址，标志位去掉PTE_W和PTE_X是因为内核只对改地址进行读取，不会修改。PTE_U是RISC-V系统独有的，有这个标志表示内核不能访问这个页面，因此也需要去掉。但是可以通过设置sstatus寄存器某一位使得内核可以访问带有PTE_U标志的页表。

    ```
    /*
    vm.c
    */
    void
    vmcopypage(pagetable_t pagetable,pagetable_t kpagetable,uint64 start,uint64 sz){
        for(uint64 i=start;i<start+sz;i+=PGSIZE){
            pte_t* pte=walk(pagetable,i,0);
            pte_t* kpte=walk(kpagetable,i,1);
            if(!pte||!kpte){
                panic("vmcopypage");
            }
            *kpte=(*pte)&~(PTE_U|PTE_W|PTE_X);
        }
    }
    ```

+ 在`def.h`中`vm.c`下添加声明

    ```
    void vmcopypage(pagetable_t,pagetable_t,uint64,uint64);
    ```

+ 在`proc.c`中调用这个函数

    ```
    /*
    proc.c
    fork()中，在np->sz = p->sz之后调用
    */
    vmcopypage(np->pagetable,np->kpagetable,0,np->sz);
    ```

+ 在`exec.c`中调用这个函数，将进程页表复制到进程的内核页表

    ```
    //释放旧进程内核页表映射
      uvmunmap(p->kpagetable,0,PGROUNDUP(oldsz)/PGSIZE,0);
      //复制进程页表到进程内核页表
      vmcopypage(pagetable,p->kpagetable,0,sz);  
    ```

+ 在`sysproc.c`修改`sys_sbrk()`函数

    ```
    uint64
    sys_sbrk(void)
    {
      int addr;
      int n;
      struct proc *p=myproc();
      if(argint(0, &n) < 0)
        return -1;
      addr = p->sz;
      if(growproc(n) < 0)
        return -1;
      if(n>0){
        vmcopypage(p->pagetable,p->kpagetable,addr,n);
      }else{
          for(int j=addr-PGSIZE;j>=addr+n;j-=PGSIZE){
              uvmunmap(p->kpagetable,j,1,0);
          }
      }
      return addr;
    }
    ```

+ 在`proc.c`修改`userinit()`，在`p->sz = PGSIZE`之后调用`vmcopypage(p->pagetable,p->kpagetable,0,PGSIZE);`

+ 在`exex.c`添加代码，在`iunlockput(ip)`前的循环末尾限制内存大小PLIC

    ```
     if(sz1>=PLIC)
          goto bad;
    ```

+ 在`proc.c`修改`proc_free_kernel_pagetable`，取消进程内核页表地址映射。

    ```
    void
    proc_freekpagetable(pagetable_t pagetable,uint64 kstack,uint64 sz){
        uvmunmap(pagetable,UART0,1,0);
        uvmunmap(pagetable,VIRTIO0,1,0);
        uvmunmap(pagetable,PLIC,0x400000/PGSIZE,0);
        uvmunmap(pagetable,KERNBASE,((uint64)etext-KERNBASE)/PGSIZE,0);
        uvmunmap(pagetable,(uint64)etext,(PHYSTOP-(uint64)etext)/PGSIZE,0);
        uvmunmap(pagetable,TRAMPOLINE,1,0);
        uvmunmap(pagetable,0,PGROUNDUP(sz)/PGSIZE,0);//实验3.3添加 3.2不添加
        uvmunmap(pagetable,kstack,1,1);
        //vmprint(pagetable);
        uvmfree(pagetable,0);
    }
    ```

#### 2.2. 程序测试

启动xv6，输入命令进行验证

```
$ usertests
```

结果如下：

```
$ usertests
usertests starting
test execout: OK
test copyin: OK
test copyout: OK
test copyinstr1: OK
test copyinstr2: OK
test copyinstr3: OK
test truncate1: OK
test truncate2: OK
test truncate3: OK
test reparent2: OK
test pgbug: OK
test sbrkbugs: usertrap(): unexpected scause 0x000000000000000c pid=3234
            sepc=0x0000000000005406 stval=0x0000000000005406
usertrap(): unexpected scause 0x000000000000000c pid=3235
            sepc=0x0000000000005406 stval=0x0000000000005406
OK
test badarg: OK
test reparent: OK
test twochildren: OK
test forkfork: OK
test forkforkfork: OK
test argptest: OK
test createdelete: OK
test linkunlink: OK
test linktest: OK
test unlinkread: OK
test concreate: OK
test subdir: OK
test fourfiles: OK
test sharedfd: OK
test exectest: OK
test bigargtest: OK
test bigwrite: OK
test bsstest: OK
test sbrkbasic: OK
test sbrkmuch: OK
test kernmem: usertrap(): unexpected scause 0x000000000000000d pid=6214
            sepc=0x000000000000201a stval=0x0000000080000000
usertrap(): unexpected scause 0x000000000000000d pid=6215
            sepc=0x000000000000201a stval=0x000000008000c350
usertrap(): unexpected scause 0x000000000000000d pid=6216
            sepc=0x000000000000201a stval=0x00000000800186a0
usertrap(): unexpected scause 0x000000000000000d pid=6217
            sepc=0x000000000000201a stval=0x00000000800249f0
usertrap(): unexpected scause 0x000000000000000d pid=6218
            sepc=0x000000000000201a stval=0x0000000080030d40
usertrap(): unexpected scause 0x000000000000000d pid=6219
            sepc=0x000000000000201a stval=0x000000008003d090
usertrap(): unexpected scause 0x000000000000000d pid=6220
            sepc=0x000000000000201a stval=0x00000000800493e0
usertrap(): unexpected scause 0x000000000000000d pid=6221
            sepc=0x000000000000201a stval=0x0000000080055730
usertrap(): unexpected scause 0x000000000000000d pid=6222
            sepc=0x000000000000201a stval=0x0000000080061a80
usertrap(): unexpected scause 0x000000000000000d pid=6223
            sepc=0x000000000000201a stval=0x000000008006ddd0
usertrap(): unexpected scause 0x000000000000000d pid=6224
            sepc=0x000000000000201a stval=0x000000008007a120
usertrap(): unexpected scause 0x000000000000000d pid=6225
            sepc=0x000000000000201a stval=0x0000000080086470
usertrap(): unexpected scause 0x000000000000000d pid=6226
            sepc=0x000000000000201a stval=0x00000000800927c0
usertrap(): unexpected scause 0x000000000000000d pid=6227
            sepc=0x000000000000201a stval=0x000000008009eb10
usertrap(): unexpected scause 0x000000000000000d pid=6228
            sepc=0x000000000000201a stval=0x00000000800aae60
usertrap(): unexpected scause 0x000000000000000d pid=6229
            sepc=0x000000000000201a stval=0x00000000800b71b0
usertrap(): unexpected scause 0x000000000000000d pid=6230
            sepc=0x000000000000201a stval=0x00000000800c3500
usertrap(): unexpected scause 0x000000000000000d pid=6231
            sepc=0x000000000000201a stval=0x00000000800cf850
usertrap(): unexpected scause 0x000000000000000d pid=6232
            sepc=0x000000000000201a stval=0x00000000800dbba0
usertrap(): unexpected scause 0x000000000000000d pid=6233
            sepc=0x000000000000201a stval=0x00000000800e7ef0
usertrap(): unexpected scause 0x000000000000000d pid=6234
            sepc=0x000000000000201a stval=0x00000000800f4240
usertrap(): unexpected scause 0x000000000000000d pid=6235
            sepc=0x000000000000201a stval=0x0000000080100590
usertrap(): unexpected scause 0x000000000000000d pid=6236
            sepc=0x000000000000201a stval=0x000000008010c8e0
usertrap(): unexpected scause 0x000000000000000d pid=6237
            sepc=0x000000000000201a stval=0x0000000080118c30
usertrap(): unexpected scause 0x000000000000000d pid=6238
            sepc=0x000000000000201a stval=0x0000000080124f80
usertrap(): unexpected scause 0x000000000000000d pid=6239
            sepc=0x000000000000201a stval=0x00000000801312d0
usertrap(): unexpected scause 0x000000000000000d pid=6240
            sepc=0x000000000000201a stval=0x000000008013d620
usertrap(): unexpected scause 0x000000000000000d pid=6241
            sepc=0x000000000000201a stval=0x0000000080149970
usertrap(): unexpected scause 0x000000000000000d pid=6242
            sepc=0x000000000000201a stval=0x0000000080155cc0
usertrap(): unexpected scause 0x000000000000000d pid=6243
            sepc=0x000000000000201a stval=0x0000000080162010
usertrap(): unexpected scause 0x000000000000000d pid=6244
            sepc=0x000000000000201a stval=0x000000008016e360
usertrap(): unexpected scause 0x000000000000000d pid=6245
            sepc=0x000000000000201a stval=0x000000008017a6b0
usertrap(): unexpected scause 0x000000000000000d pid=6246
            sepc=0x000000000000201a stval=0x0000000080186a00
usertrap(): unexpected scause 0x000000000000000d pid=6247
            sepc=0x000000000000201a stval=0x0000000080192d50
usertrap(): unexpected scause 0x000000000000000d pid=6248
            sepc=0x000000000000201a stval=0x000000008019f0a0
usertrap(): unexpected scause 0x000000000000000d pid=6249
            sepc=0x000000000000201a stval=0x00000000801ab3f0
usertrap(): unexpected scause 0x000000000000000d pid=6250
            sepc=0x000000000000201a stval=0x00000000801b7740
usertrap(): unexpected scause 0x000000000000000d pid=6251
            sepc=0x000000000000201a stval=0x00000000801c3a90
usertrap(): unexpected scause 0x000000000000000d pid=6252
            sepc=0x000000000000201a stval=0x00000000801cfde0
usertrap(): unexpected scause 0x000000000000000d pid=6253
            sepc=0x000000000000201a stval=0x00000000801dc130
OK
test sbrkfail: usertrap(): unexpected scause 0x000000000000000d pid=6265
            sepc=0x0000000000003e7a stval=0x0000000000012000
OK
test sbrkarg: OK
test validatetest: OK
test stacktest: usertrap(): unexpected scause 0x000000000000000d pid=6269
            sepc=0x0000000000002188 stval=0x000000000000fbc0
OK
test opentest: OK
test writetest: OK
test writebig: OK
test createtest: OK
test openiput: OK
test exitiput: OK
test iput: OK
test mem: OK
test pipe1: OK
test preempt: kill... wait... OK
test exitwait: OK
test rmdot: OK
test fourteen: OK
test bigfile: OK
test dirfile: OK
test iref: OK
test forktest: OK
test bigdir: OK
ALL TESTS PASSED
$
```

### 3. 注意事项与提示

通过调用定义在kernel/vmcopyin.c中的函数`copyin_new`来替换`copyin`的实现过程，对`copyinstr`和`copyinstr_new`做同样的替换工作。

‎此方案的正常供工作依赖于用户虚拟地址的范围不会覆盖内核用于其自身指令和数据的虚拟地址范围（PLIC～MAXVA）。Xv6 使用从零开始的虚拟地址来访问用户地址空间，幸运的是，内核的内存从更高的地址开始。因此，我们要保证用户过程的最大虚拟地址大小小于内核的最低虚拟地址。内核启动后，该地址在 xv6 中‎‎`0xC000000`，‎‎即 `PLIC` 寄存器的地址;请参阅kernel/vm.c中的‎‎`kvminit()` , kernel/memlayout.h 和图 3-4。您需要修改 xv6 以防止用户进程越过 `PLIC` 地址。‎

- 在改动`copyinstr`之前，首先确保完成：通过调用定义在kernel/vmcopyin.c中的函数`copyin_new`来替换`copyin`的实现过程。
- 在每一个内核改变了用户映射的地方，对进程的内核页表的做相同的改变。包括`fork()`, `exec()`, and `sbrk()`。
- 在`userinit` 中不要忘记将第一个进程的用户页表包含进其内核页表中。
- 在内核页表中的相关用户地址的`PTEs` 需要哪些权限？（如果一页的PTE_U位被设置，则不能在内核模式下访问）。
- 不要忘记前面提到的PLIC限制。

## 四. 总实验结果

在目录下创建`time.txt`，并输入完成实验的小时数。在终端执行

```
 ./grade-lab-pgtbl
```

来对实验结果进行完全测试。

测试结果如下：

```
== Test pte printout ==
$ make qemu-gdb
pte printout: OK (4.7s)
== Test answers-pgtbl.txt == answers-pgtbl.txt: OK
== Test count copyin ==
$ make qemu-gdb
count copyin: OK (1.3s)
== Test usertests ==
$ make qemu-gdb
(111.0s)
== Test   usertests: copyin ==
  usertests: copyin: OK
== Test   usertests: copyinstr1 ==
  usertests: copyinstr1: OK
== Test   usertests: copyinstr2 ==
  usertests: copyinstr2: OK
== Test   usertests: copyinstr3 ==
  usertests: copyinstr3: OK
== Test   usertests: sbrkmuch ==
  usertests: sbrkmuch: OK
== Test   usertests: all tests ==
  usertests: all tests: OK
== Test time ==
time: OK
Score: 66/66
```

## 五. 遇到的问题及解决方法

第二个实验中，在`proc.c`中调用函数`proc_pagetable`与`uvmmap`，运行报错。原因是`proc.c`没有获取到这两个函数的声明。

解决方法：在`kenel/defs.h`下补充函数的声明



# Lab4. traps

## 一. RISC-V assembly ([easy](https://pdos.csail.mit.edu/6.828/2020/labs/guidance.html))

### 1. 实验要求

本实验探讨如何使用陷阱实现系统调用。 您将首先对堆栈进行热身练习，然后实现用户级陷阱处理的示例。了解一些RISC-V程序集非常重要，这在6.004中已经介绍过。 xv6存储库中有一个文件user / call.c。 make fs.img对其进行编译，并在user / call.asm中生成该程序的可读汇编版本。

阅读call.asm中有关g，f和main函数的代码。 RISC-V的说明手册在参考页上。 以下是您应回答的一些问题（将回答存储在文件Answers-traps.txt中）：

### 2. 实验问题

#### 2.1. 哪些寄存器包含函数的参数？ 例如，哪个寄存器在main对printf的调用中保留13？

RISC-V 使用 `a0-a7` 存放函数的传入参数，13 保存在 `a2` 寄存器中。

#### 2.2. 在main的汇编代码中对函数f的调用在哪里？对函数g的调用在哪里？ （提示：编译器可以内联函数。）

编译器优化后；无函数调用。编译器直接将 `f(8)+1=12` 计算完成并放入` a1`。

#### 2.3. 函数printf位于哪个地址？

`0x630`

#### 2.4. 在main中jalr到printf后，ra寄存器的值多少？

`0x38`

`jalr rd, offset(rs1)` 会将`pc+4 `的数值存入 `rd `中，如果 `rd` 是 `ra` 的话代表这个指令相当于函数调用，否则就只是单纯的跳转，支持的范围为以` rs1 `为基础的 ±2KB (-2048 ~ 2047)。 auipc 的高20位搭配 jalr 的低12位，就可以调用 pc在32位范围内的所有函数。 所以 `ra` 此时的值为` 0x38`

#### 2.5. 运行下面的代码，回答问题

````C
unsigned int i = 0x00646c72;
printf("H%x Wo%s", 57616, &i);      
````

**程序输出是什么？**
**如果 RISC-V 是大端序的，要实现同样的效果，需要将 i 设置为什么？需要将 57616 修改为别的值吗？**

输出是`He110 World`；需要将i设置为`0x726c6400`；`57616` 不需要修改。

`％x` 表示以十六进制数形式输出整数，`57616` 的16进制表示就是 `e110`，与大小端序无关。
`%s` 是输出字符串，以整数 i 所在的开始地址，按照字符的格式读取字符，直到读取到 ‘\0’ 为止。当是小端序表示的时候，内存中存放的数是：`72 6c 64 00`。若改为大端序，则反过来了，因此需要将 i 以16进制数的方式逆转一下。

#### 2.6. 在下面的代码中，“`y=`”之后将打印什么(注：答案不是一个特定的值）？为什么会发生这种情况？

```
printf("x=%d y=%d", 3);
```

将打印 `x=3 y=`。这是因为 `printf` 函数中的格式字符串 `"x=%d y=%d"` 包含了两个 `%d` 格式说明符，但只提供了一个整数参数 `3`。

## 二. Backtrace ([moderate](https://pdos.csail.mit.edu/6.828/2020/labs/guidance.html))

### 1. 实验要求

对于调试来说，有一个`backtrace`通常是有用的：error发生点之前，栈上的一系列函数调用。`kernel/printf.c`中实现`backtrace()`函数。

在`sys_sleep()`中插入对这个函数的调用，然后运行`bttest`，它调用`sys_sleep`。编写函数 `backtrace()`, 遍历读取栈帧(frame pointer)并输出函数返回地址.

### 2. 实验步骤

#### 2.1. 编写代码并配置

+ 在`kernel/defs.h`添加`backtrace()`函数的定义，使得`sys_sleep`可以调用这个函数

    ```
    //printf.c
    void			backtrace();
    ```

+ 根据提示，在`kernel/riscv.h`中添加内联函数`r_fp()`读取栈帧值，函数代码如下：

    ```
    static inline uint64
    r_fp()
    {
      uint64 x;
      asm volatile("mv %0, s0" : "=r" (x));
      return x;
    }
    
    ```

+ 在`kernel/printf.c`中实现`backtrace()`函数。该函数输出所有的栈帧。初始通过调用上述的 `r_fp()` 函数读取寄存器 s0 中的当前函数栈帧 fp. 根据 RISC-V 的栈结构, fp-8 存放返回地址, fp-16 存放原栈帧. 进而通过原栈帧得到上一级栈结构, 直到获取到最初的栈结构。

    ```
    //lab 4-2 backtrace
    void backtrace() {
        uint64 fp = r_fp();    // 获取当前栈帧
        uint64 top = PGROUNDUP(fp);    // 获取用户栈最高地址
        uint64 bottom = PGROUNDDOWN(fp);    // 获取用户栈最低地址
        for (; 
            fp >= bottom && fp < top;     // 终止条件
            fp = *((uint64 *) (fp - 16))    // 获取下一栈帧
            ) {
            printf("%p\n", *((uint64 *) (fp - 8)));    // 输出当前栈中返回地址
        }
    }
    ```

+ 在`kernel/sysproc.c`的`sys_sleep()`函数中调用`backtrace()`

    ```
    uint64
    sys_sleep(void){
        int n;
        uint ticks0;
        if(argint(0,&n)< 0)
            return -1;
        acquire(&tickslock);
        ticks0 = ticks;
        while(ticks - ticks0< n){
            if(myproc()->killed){
                release(&tickslock);
                return -1;
        }
        sleep(&ticks,&tickslock);
        }
        release(&tickslock);
        backtrace();//new code
        return 0;
    }
    ```

+ 在`kernel/printf.c`的函数`panic()`中调用`backtrace()`

    ```
    void
    panic(char *s)
    {
      pr.locking = 0;
      printf("panic: ");
      printf(s);
      printf("\n");
      backtrace();//new code
      panicked = 1; // freeze uart output from other CPUs
      for(;;)
        ;
    }
    ```

#### 2.2. 程序测试

启动xv6，输入指令`bttest`测试，输出 3 个栈帧的返回地址

```
$ bttest
0x0000000080002d96
0x0000000080002bf8
0x00000000800028a8
$
```

退出xv6进行单元测试

```bash
$ ./grade-lab-traps backtrace
```

单元测试通过

```
make: 'kernel/kernel' is up to date.
== Test backtrace test == backtrace test: OK (1.6s)
```

### 3. 注意事项与提示

你的输出应该是：
backtrace:
0x0000000080002cda
0x0000000080002bb6
0x0000000080002898
在bttest之后退出qemu。在你的`terminal`中：地址可能是不同的，但如果你运行`addr2line -e kernel/kernel（riscv64-unknown-elf-addr2line -e kernel/kernel）`并且把上面地址复制粘贴如下所示：

````bash
$ addr2line -e kernel/kernel
0x0000000080002de2
0x0000000080002f4a
0x0000000080002bfc
Ctrl-D
````

你应该可以看到像下面所示：

````BASH
kernel/sysproc.c:74
kernel/syscall.c:224
kernel/trap.c:85
````

编译器在每个栈帧中放入一个帧指针，该指针保留调用方帧指针的地址。你的`backtrace`应该使用这些帧指针，来遍历stack并且打印每个栈帧中保存的返回地址。

* 添加`backtrace`原型到`kernel/defs.h`，以便于你可以在`sys_sleep`中调用。

* GCC编译器存储当前执行函数的帧指针在寄存器`S0`，添加下面函数到`kernel/risc.h`：

    ````C
     static inline uint64 r_fp(){   
         uint64 x;    
         asm volatile(“mv %0, s0” : “=r” (x) ); 
     }
    ````

* 在backtrace中调用这个函数来读取当前帧指针。这个函数使用内联汇编来读取s0。

* 这些讲义有一个栈帧布局的图片。注意返回地址位于一个固定偏移量（对栈帧的帧指针偏移-8），保存的帧指针位于固定偏移量（对帧指针偏移-16）

* xv6为每个`kernel stack`分配一页于页对齐地址。你可以计算栈页的顶部和底部地址，通过使用`PGROUNDDOWN(fp)`和`PGROUNDUP(fp)`（看`kernel/riscv.h`，这些数字对`backtrace`终止循环是有帮助的）。

* 一旦你的`backtrace`起作用，`panic（kernel/printf.c）`调用它，以便于在`panic`时可以看到`kernel`的`backtrace`。

## 三. Alarm ([hard](https://pdos.csail.mit.edu/6.828/2020/labs/guidance.html))

### 1. 实验目的

在本练习中，您将向xv6添加一项功能，该功能会在使用CPU时间的情况下定期向进程发出警报。 这对于想要限制消耗多少CPU时间的计算密集型进程，或者对于想要进行计算但还希望采取一些定期操作的进程很有用。 更一般而言，您将实现用户级中断/故障处理程序的原始形式。 例如，您可以使用类似的方法来处理应用程序中的页面错误。 您的解决方案是否通过Alarmtest和UserTests是正确的。

### 2. 实验步骤

#### 2.1. 编写代码并配置

##### 1）test0 invoke handler

+ 在 `user/user.h` 中添加两个系统调用的函数原型:

    ````C
    int sigalarm(int ticks,void (*handler)());
    int sigreturn(void);
    ````


+ 在 `user/usys.pl` 脚本中添加上述两个系统调用的相应入口

    ```
    entry("sigalarm");
    entry("sigreturn");
    ```

+ 在 `kernel/syscall.h` 和 `kernel/syscall.c` 添加相应声明

    ```
    //kernel/syscall.h
    #define SYS_sigalarm  22
    #define SYS_sigreturn  23
    
    
    //kernel/syscall.c
    extern uint64 sys_sigalarm(void);//new
    extern uint64 sys_sigreturn(void);
    ...
    static uint64 (*syscalls[])(void) = {
    ...
    [SYS_sigalarm]  sys_sigalarm,
    [SYS_sigreturn] sys_sigreturn,
    }
    ```

+ 在`kernel/sysproc.c`中编写当前test0需要的`sys_sigreturn()`函数，现在只需要返回0

    ```
    //kernel/sysproc.c
    uint64 
    sys_sigreturn(void) {
        return 0;
    }
    ```

+ `kernel/proc.h` 定义了进程的结构体`proc`，为它新增数据成员来记录时间间隔, 调用函数地址, 以及经过时钟数。

    ```
    //kernel/proc.h
    struct proc {
    .....
      int interval;      //时间间隔
      uint64 handler;	//调用函数地址
      int passedticks;	//经过的时钟数
    };
    ```

+ 在`kernel/sysproc.c`实现`sys_sigalarm()`函数，将 `interval` 和 `handler` 的值存到当前进程的 `proc` 结构体的相应字段中。

    ```
    //kernel/sysproc.c
    uint64
    sys_sigalarm(void) {
        int interval;
        uint64 handler;
        struct proc *p;
        // 要求时间间隔非负
        if (argint(0, &interval) < 0 || argaddr(1, &handler) < 0 || interval < 0) {
            return -1;
        }
        // lab4-3
        p = myproc();
        p->interval = interval;
        p->handler = handler;
        p->passedticks = 0;    // 重置过去时钟数
    
        return 0;
    }
    ```

+ 在`kernel/proc.c`的 `allocproc()` 函数中完成对进程`proc`三个新字段的初始化赋值

    ```
    //proc新字段的初始化赋值
      p->interval=0;
      p->handler=0;
      p->passedticks=0;
    ```

+ 在`kernel/trap.c`的`usertrap()`函数，为时钟中断添加相应的处理代码

    ```
    void
    usertrap(void)
    {
      int which_dev = 0;
      // ...
    
      if(p->killed)
        exit(-1);
    
      // new code
      if(which_dev == 2){   // 时钟中断
        // 时钟计数加一
        if(p->interval != 0 && ++p->passedticks == p->interval){
          p->passedticks = 0;
          p->trapframe->epc = p->handler;   //执行handler（）
        }
      }
        
        
      // give up the CPU if this is a timer interrupt.
      if(which_dev == 2)
        yield();
    
      usertrapret();
    }
    ```

+ 修改`Makefile`中`UPROGS`,添加对 `alarmtest.c` 的编译

    ```
    	$U/_alarmtest\
    ```

##### 2）test1/test2  resume interrupted code

+ 修改`kernel/proc.h`的`proc`结构体，新增 `trapframe` 的副本字段。

    ```
     struct trapframe* trapframecopy; 
    ```

+ 在 `kernel/trap.c` 的 `usertrap()` 中覆盖 `p->trapframe->epc` 前做 `trapframe` 的副本.

    ```
    void
    usertrap(void)
    {
      // ...
      // lab4-3
      if(which_dev == 2){   // timer interrupt
        // increase the passed ticks
        if(p->interval != 0 && ++p->passedticks == p->interval){  
          // 使用 trapframe 后的一部分内存, trapframe大小为288B, 因此只要在trapframe地址后288以上地址都可, 此处512只是为了取整数幂
          p->trapframecopy = p->trapframe + 512;  
          memmove(p->trapframecopy,p->trapframe,sizeof(struct trapframe));    		// 复制 trapframe
          p->trapframe->epc = p->handler;  //执行handler（）
        }
      }
      // ...
    }
    ```

+ 在 ``kernel/sysproc.c`完成`sys_sigreturn()`函数，它将副本恢复到原 `trapframe`.

    ```
    uint64
    sys_sigreturn(void) {
        struct proc* p = myproc();
    
        if(p->trapframecopy != p->trapframe + 512) {
            return -1;
        }
        memmove(p->trapframe, p->trapframecopy, sizeof(struct trapframe));   	// 恢复  trapframe
        p->passedticks = 0;     
        p->trapframecopy = 0;    // 置零
        return 0;
    }
    ```

+ 在初始进程 `kernel/proc.c` 的 `allocproc()` 中, 初始化 `p->trapframecopy` 为 0, 表明初始时无副本.

    ```
    p->trapframecopy=0;
    ```

#### 2.2. 程序测试

启动xv6，输入`alarmtest`，test通过

```
$ alarmtest
test0 start
.............alarm!
test0 passed
test1 start
...alarm!
...alarm!
....alarm!
....alarm!
...alarm!
...alarm!
...alarm!
...alarm!
...alarm!
....alarm!
.test1 passed
test2 start
................alarm!
test2 passed
$
```

输入usertests，test通过

```
$ usertests
usertests starting
test execout: OK
test copyin: OK
test copyout: OK
test copyinstr1: OK
test copyinstr2: OK
test copyinstr3: OK
test truncate1: OK
test truncate2: OK
test truncate3: OK
test reparent2: OK
test pgbug: OK
test sbrkbugs: usertrap(): unexpected scause 0x000000000000000c pid=3236
            sepc=0x0000000000005406 stval=0x0000000000005406
usertrap(): unexpected scause 0x000000000000000c pid=3237
            sepc=0x0000000000005406 stval=0x0000000000005406
OK
test badarg: OK
test reparent: OK
test twochildren: OK
test forkfork: OK
test forkforkfork: 0x0000000080002d96
0x0000000080002bf8
0x00000000800028a8
0x0000000080002d96
0x0000000080002bf8
0x00000000800028a8
OK
test argptest: OK
test createdelete: OK
test linkunlink: OK
test linktest: OK
test unlinkread: OK
test concreate: OK
test subdir: OK
test fourfiles: OK
test sharedfd: OK
test exectest: OK
test bigargtest: OK
test bigwrite: OK
test bsstest: OK
test sbrkbasic: OK
test sbrkmuch: OK
test kernmem: usertrap(): unexpected scause 0x000000000000000d pid=6216
            sepc=0x000000000000201a stval=0x0000000080000000
usertrap(): unexpected scause 0x000000000000000d pid=6217
            sepc=0x000000000000201a stval=0x000000008000c350
usertrap(): unexpected scause 0x000000000000000d pid=6218
            sepc=0x000000000000201a stval=0x00000000800186a0
usertrap(): unexpected scause 0x000000000000000d pid=6219
            sepc=0x000000000000201a stval=0x00000000800249f0
usertrap(): unexpected scause 0x000000000000000d pid=6220
            sepc=0x000000000000201a stval=0x0000000080030d40
usertrap(): unexpected scause 0x000000000000000d pid=6221
            sepc=0x000000000000201a stval=0x000000008003d090
usertrap(): unexpected scause 0x000000000000000d pid=6222
            sepc=0x000000000000201a stval=0x00000000800493e0
usertrap(): unexpected scause 0x000000000000000d pid=6223
            sepc=0x000000000000201a stval=0x0000000080055730
usertrap(): unexpected scause 0x000000000000000d pid=6224
            sepc=0x000000000000201a stval=0x0000000080061a80
usertrap(): unexpected scause 0x000000000000000d pid=6225
            sepc=0x000000000000201a stval=0x000000008006ddd0
usertrap(): unexpected scause 0x000000000000000d pid=6226
            sepc=0x000000000000201a stval=0x000000008007a120
usertrap(): unexpected scause 0x000000000000000d pid=6227
            sepc=0x000000000000201a stval=0x0000000080086470
usertrap(): unexpected scause 0x000000000000000d pid=6228
            sepc=0x000000000000201a stval=0x00000000800927c0
usertrap(): unexpected scause 0x000000000000000d pid=6229
            sepc=0x000000000000201a stval=0x000000008009eb10
usertrap(): unexpected scause 0x000000000000000d pid=6230
            sepc=0x000000000000201a stval=0x00000000800aae60
usertrap(): unexpected scause 0x000000000000000d pid=6231
            sepc=0x000000000000201a stval=0x00000000800b71b0
usertrap(): unexpected scause 0x000000000000000d pid=6232
            sepc=0x000000000000201a stval=0x00000000800c3500
usertrap(): unexpected scause 0x000000000000000d pid=6233
            sepc=0x000000000000201a stval=0x00000000800cf850
usertrap(): unexpected scause 0x000000000000000d pid=6234
            sepc=0x000000000000201a stval=0x00000000800dbba0
usertrap(): unexpected scause 0x000000000000000d pid=6235
            sepc=0x000000000000201a stval=0x00000000800e7ef0
usertrap(): unexpected scause 0x000000000000000d pid=6236
            sepc=0x000000000000201a stval=0x00000000800f4240
usertrap(): unexpected scause 0x000000000000000d pid=6237
            sepc=0x000000000000201a stval=0x0000000080100590
usertrap(): unexpected scause 0x000000000000000d pid=6238
            sepc=0x000000000000201a stval=0x000000008010c8e0
usertrap(): unexpected scause 0x000000000000000d pid=6239
            sepc=0x000000000000201a stval=0x0000000080118c30
usertrap(): unexpected scause 0x000000000000000d pid=6240
            sepc=0x000000000000201a stval=0x0000000080124f80
usertrap(): unexpected scause 0x000000000000000d pid=6241
            sepc=0x000000000000201a stval=0x00000000801312d0
usertrap(): unexpected scause 0x000000000000000d pid=6242
            sepc=0x000000000000201a stval=0x000000008013d620
usertrap(): unexpected scause 0x000000000000000d pid=6243
            sepc=0x000000000000201a stval=0x0000000080149970
usertrap(): unexpected scause 0x000000000000000d pid=6244
            sepc=0x000000000000201a stval=0x0000000080155cc0
usertrap(): unexpected scause 0x000000000000000d pid=6245
            sepc=0x000000000000201a stval=0x0000000080162010
usertrap(): unexpected scause 0x000000000000000d pid=6246
            sepc=0x000000000000201a stval=0x000000008016e360
usertrap(): unexpected scause 0x000000000000000d pid=6247
            sepc=0x000000000000201a stval=0x000000008017a6b0
usertrap(): unexpected scause 0x000000000000000d pid=6248
            sepc=0x000000000000201a stval=0x0000000080186a00
usertrap(): unexpected scause 0x000000000000000d pid=6249
            sepc=0x000000000000201a stval=0x0000000080192d50
usertrap(): unexpected scause 0x000000000000000d pid=6250
            sepc=0x000000000000201a stval=0x000000008019f0a0
usertrap(): unexpected scause 0x000000000000000d pid=6251
            sepc=0x000000000000201a stval=0x00000000801ab3f0
usertrap(): unexpected scause 0x000000000000000d pid=6252
            sepc=0x000000000000201a stval=0x00000000801b7740
usertrap(): unexpected scause 0x000000000000000d pid=6253
            sepc=0x000000000000201a stval=0x00000000801c3a90
usertrap(): unexpected scause 0x000000000000000d pid=6254
            sepc=0x000000000000201a stval=0x00000000801cfde0
usertrap(): unexpected scause 0x000000000000000d pid=6255
            sepc=0x000000000000201a stval=0x00000000801dc130
OK
test sbrkfail: usertrap(): unexpected scause 0x000000000000000d pid=6267
            sepc=0x0000000000003e7a stval=0x0000000000012000
OK
test sbrkarg: OK
test validatetest: OK
test stacktest: usertrap(): unexpected scause 0x000000000000000d pid=6271
            sepc=0x0000000000002188 stval=0x000000000000fbc0
OK
test opentest: OK
test writetest: OK
test writebig: OK
test createtest: OK
test openiput: 0x0000000080002d96
0x0000000080002bf8
0x00000000800028a8
OK
test exitiput: OK
test iput: OK
test mem: OK
test pipe1: OK
test preempt: kill... wait... OK
test exitwait: OK
test rmdot: OK
test fourteen: OK
test bigfile: OK
test dirfile: OK
test iref: OK
test forktest: OK
test bigdir: OK
ALL TESTS PASSED
$
```

退出xv6进行单元测试

```bash
$ ./grade-lab-traps alarmtest 
```

单元测试通过

```
make: 'kernel/kernel' is up to date.
== Test running alarmtest == (5.2s)
== Test   alarmtest: test0 ==
  alarmtest: test0: OK
== Test   alarmtest: test1 ==
  alarmtest: test1: OK
== Test   alarmtest: test2 ==
  alarmtest: test2: OK
```

### 3. 注意事项与提示

您应该添加一个新的`sigalarm（interval，handler）`系统调用。 如果应用程序调用sigalarm（n，fn），则在程序每消耗n个“ tick” CPU时间之后，内核应导致调用应用程序函数fn。 当fn返回时，应用程序应从中断处恢复。 滴答是xv6中相当随意的时间单位，由硬件计时器产生中断的频率决定。 如果应用程序调用sigalarm（0，0），则内核应停止生成定期警报调用。

您将在xv6存储库中找到一个文件`user / alarmtest.c`。 将其添加到Makefile。 在您添加了sigalarm和sigreturn系统调用之前，它无法正确编译（请参见下文）。

alarmtest在test0中调用sigalarm（2，periodic），以要求内核每2个滴答强制一次对periodic（）的调用，然后旋转一段时间。 您可以在user / alarmtest.asm中看到alarmtest的汇编代码，这对于调试很方便。 当alarmtest产生这样的输出并且usertests也正确运行时，您的解决方案是正确的：

````bash
$ alarmtest
test0 start
........alarm!
test0 passed
test1 start
...alarm!
..alarm!
...alarm!
..alarm!
...alarm!
..alarm!
...alarm!
..alarm!
...alarm!
..alarm!
test1 passed
test2 start
................alarm!
test2 passed
$ usertests
...
ALL TESTS PASSED
$
````

## 四. 总实验结果

在目录下创建`time.txt`，并输入完成实验的小时数。在终端执行

```
 ./grade-lab-traps
```

来对实验结果进行完全测试。

测试结果如下：

```
make: 'kernel/kernel' is up to date.
== Test answers-traps.txt == answers-traps.txt: OK
== Test backtrace test == backtrace test: OK (1.4s)
== Test running alarmtest == (3.9s)
== Test   alarmtest: test0 ==
  alarmtest: test0: OK
== Test   alarmtest: test1 ==
  alarmtest: test1: OK
== Test   alarmtest: test2 ==
  alarmtest: test2: OK
== Test usertests == usertests: OK (84.1s)
== Test time ==
time: OK
Score: 85/85
```

## 五. 遇到的问题以及解决方法

`make grade`报错fail，读取`answers_traps.txt`失败。

解决：在根目录下创建`answers_traps.txt`文件，写入一些文字以及数字。



# Lab5. xv6 lazy page allocation

## 一. Eliminate allocation from sbrk() ([easy](https://pdos.csail.mit.edu/6.828/2020/labs/guidance.html))

### 1. 实验要求

您的第一个任务是从`sbrk（n）`系统调用实现中删除页面分配，该实现是`sysproc.c`中的`sys_sbrk（）`函数。 

### 2. 实验步骤

#### 2.1. 编写代码并配置

在`kernel/sysproc.c`修改 `sys_sbrk()` 函数, 删去原本调用的 `growproc()` 函数，使新的`sbrk(n)`应该只将进程的大小（`myproc()->sz`）增加n，然后返回旧的大小。

```
uint64
sys_sbrk(void)
{
  int addr;
  int n;

  if(argint(0, &n) < 0)
    return -1;
  
  //lab 5-1 add
  addr = myproc()->sz;
  // lazy allocation
  myproc()->sz += n;
  // lab 5-1 delete
  /*if(growproc(n) < 0)
    return -1;*/
  return addr;
}
```

#### 2.2. 程序测试

启动xv6后，运行命令`echo hi`，输出结果如下：

```
$ echo hi
usertrap(): unexpected scause 0x000000000000000f pid=3
            sepc=0x00000000000012ac stval=0x0000000000004008
panic: uvmunmap: not mapped
```

### 3. 注意事项与提示

* `sbrk（n）`系统调用将进程的内存大小增加n个字节，然后返回新分配的区域的开始位置（即旧大小）。 您的新`sbrk（n）`应该仅将进程的大小（myproc（）-> sz）增加n并返回旧的大小。 它不应该分配内存-因此您应该删除对growproc（）的调用（但是您仍然需要增加进程的大小！）。

* 尝试猜测一下此修改的结果是什么：将中断吗？进行此修改，启动xv6，然后在shell中输入`echo hi`。 您应该会看到以下内容：

````bash
init: starting sh
$ echo hi
usertrap(): unexpected scause 0x000000000000000f pid=3
            sepc=0x0000000000001258 stval=0x0000000000004008
va=0x0000000000004000 pte=0x0000000000000000
panic: uvmunmap: not mapped
````

* `“ usertrap（）：...”`消息来自用户陷阱处理程序` trap.c`; 它捕获了一个不知道如何处理的异常。 确保您了解为什么发生此页面错误。 **“ stval = 0x0..04008”指示导致页面错误的虚拟地址为0x4008**。

## 二. Lazy allocation ([moderate](https://pdos.csail.mit.edu/6.828/2020/labs/guidance.html))

### 1. 实验要求

修改trap.c中的代码，以通过在故障地址处映射新分配的物理内存页面，然后返回用户空间以使进程继续执行，来响应用户空间中的页面错误。 您应该在产生“ usertrap（）：...”消息的printf调用之前添加代码。 修改您需要的其他xv6内核代码，以使echo hi起作用。

### 2. 实验步骤

#### 2.1. 编写代码并配置

+ 在 `kernel/trap.c` 的 `usertrap()` 中添加对 page fault 的处理.

    当 r_scause() 的值为 13 和 15 时为需要处理的 page fault 情况。系统调用的中断码是 8，page fault 的中断码是 13 和 15。因此，这里我们对 r_scause() 中断原因进行判断，如果是 13 或是 15，则说明没有找到地址。错误的虚拟地址被保存在了 STVAL 寄存器中，我们取出该地址进行分配。如果申请物理地址没成功或者虚拟地址超出范围了，那么杀掉进程。如果申请内存成功了，如果虚拟地址不合法，需要再释放掉这块内存。中断判断时，如果出错（虚拟地址不合法或者没有成功映射到物理地址），就杀死进程。

    ```
    void
    usertrap(void)
    {
      //...
      //lab 5-2
      else if (r_scause() == 13 || r_scause() == 15) {  
        char *pa;
        if((pa = kalloc()) != 0) {    // 分配物理页
          uint64 va = PGROUNDDOWN(r_stval());   // 引发page fault的虚拟地址向下取整
          memset(pa, 0, PGSIZE);
          // 进行页表映射
          if(mappages(p->pagetable, va, PGSIZE, (uint64)pa, PTE_W|PTE_R|PTE_U) != 0) {
              // 页表映射失败
              kfree(pa);
              printf("usertrap(): mappages() failed\n");
              p->killed = 1;
          }
        } else {    // 分配物理页失败
          printf("usertrap(): kalloc() failed\n");
          p->killed = 1;
        }
      } 
      else if((which_dev = devintr()) != 0){
        // ok
      } 
      else {
        printf("usertrap(): unexpected scause %p pid=%d\n", r_scause(), p->pid);
        printf("            sepc=%p stval=%p\n", r_sepc(), r_stval());
        p->killed = 1;
      }
    
      // give up the CPU if this is a timer interrupt.
      if(which_dev == 2)
        yield();
    
      usertrapret();
    }
    ```

+ 处理 `uvmunmap` 的报错

    `uvmunmap` 是用来释放内存调用的，由于释放内存时，页表内有些地址并没有实际分配内存，因此没有进行映射。如果在 `uvmunmap` 中发现了没有映射的地址，直接跳过，不需要 panic.

    修改`kernal/vm.c`的`uvmunmap()`函数如下

    ```
    void
    uvmunmap(pagetable_t pagetable, uint64 va, uint64 npages, int do_free)
    {
      uint64 a;
      pte_t *pte;
    
      if((va % PGSIZE) != 0)
        panic("uvmunmap: not aligned");
    
      for(a = va; a < va + npages*PGSIZE; a += PGSIZE){
        if((pte = walk(pagetable, a, 0)) == 0)
          panic("uvmunmap: walk");
        if((*pte & PTE_V) == 0)
          //panic("uvmunmap: not mapped");
          continue;   //lab 5-2 add
        if(PTE_FLAGS(*pte) == PTE_V)
          panic("uvmunmap: not a leaf");
        if(do_free){
          uint64 pa = PTE2PA(*pte);
          kfree((void*)pa);
        }
        *pte = 0;
      }
    }
    ```

#### 2.2. 程序测试

运行xv6，输入命令`echo hi`，输出结果如下

```
$ echo hi
hi
$
```

### 3. 注意事项与提示

* 您可以通过查看usertrap（）中的r_scause（）是13还是15来检查故障是否是页面错误。

* r_stval（）返回RISC-V stval寄存器，其中包含导致页面错误的虚拟地址。

* 从vm.c中的uvmalloc（）窃取代码，这就是sbrk（）调用的代码（通过growproc（））。 您需要调用kalloc（）和mappages（）。

* 使用PGROUNDDOWN（va）将有问题的虚拟地址向下舍入到页面边界。

* uvmunmap（）会惊慌； 如果未映射某些页面，请将其修改为不会出现紧急情况。

* 如果内核崩溃，请在kernel / kernel.asm中查找sepc。

* 使用pgtbl lab中的vmprint函数来打印页表的内容。

* 如果看到错误“不完整类型的proc”，请包含“ spinlock.h”，然后包含“ proc.h”。

* 如果一切顺利，您的延迟分配代码应会导致echo hi工作。 您应该至少遇到一个页面错误（并因此导致延迟分配），也许要得到两个。

## 三. Lazytests and Usertests ([moderate](https://pdos.csail.mit.edu/6.828/2020/labs/guidance.html))

### 1. 实验要求

实验中提供了`lazytests`，这是一个xv6用户程序，它测试一些可能会给您的惰性内存分配器带来压力的特定情况。修改内核代码，使所有`lazytests`和`usertests`都通过。

### 2. 实验步骤

#### 2.1. 编写代码并配置

+ 当`kernel/sysproc.c` 中 `sys_sbrk()` 参数为负数时

    这里处理的方法可以参考原本调用的 `growproc()` 函数，对 `addr+n` 进行进一步判断, 要求其值要大于等于 `PGROUNDUP(p->trapframe->sp)`,此外, 由于 `addr` 和 `n` 是 `int` 类型, 因此要进行防溢出操作 `addr+n>=addr`, 避免 `addr+n` 由正变负造成 `p->sz` 变小的情况。

    ```
    uint64
    sys_sbrk(void)
    {
      int addr;
      int n;
      struct proc *p;
    
      if(argint(0, &n) < 0)
        return -1;
      p = myproc();
      addr = p->sz;
      
      if(n >= 0 && addr + n >= addr){
        p->sz += n;    
      } else if(n < 0 && addr + n >= PGROUNDUP(p->trapframe->sp)){
        
        p->sz = uvmdealloc(p->pagetable, addr, addr + n);
      } else {
        return -1;
      }
    
    //  if(growproc(n) < 0)
    //    return -1;
      return addr;
    }
    ```

+ 修改 `kernel/vm.c` 中的 `uvmunmap()` 函数, 将`if((pte = walk(pagetable, a, 0)) == 0)` 的情况由引发 panic 改为 continue 跳过。`if((pte = walk(pagetable, a, 0)) == 0)` 是在判断虚拟地址 `a` 在页表 `pagetable` 中的页表项是否存在。 此时, 一般是 sbrk() 申请了较大内存， L2 或 L1 中的 PTE 就未分配，致使 L0 页目录就不存在, 虚拟地址对应的 PTE 也就不存在。

    ```
    void
    uvmunmap(pagetable_t pagetable, uint64 va, uint64 npages, int do_free)
    {
      uint64 a;
      pte_t *pte;
    
      if((va % PGSIZE) != 0)
        panic("uvmunmap: not aligned");
    
      for(a = va; a < va + npages*PGSIZE; a += PGSIZE){
        if((pte = walk(pagetable, a, 0)) == 0) {
          continue;  
    //      panic("uvmunmap: walk");   
        }
        if((*pte & PTE_V) == 0) {
          continue;     // lab5-2
    //      panic("uvmunmap: not mapped"); 
        }
        if(PTE_FLAGS(*pte) == PTE_V)
          panic("uvmunmap: not a leaf");
        if(do_free){
          uint64 pa = PTE2PA(*pte);
          kfree((void*)pa);
        }
        *pte = 0;
      }
    }
    ```

+ 在`fork()`中正确处理父到子内存拷贝

    `fork()` 是通过 `uvmcopy()` 来进行父进程页表即用户空间向子进程拷贝的. 而对于 `uvmcopy()` 的处理和 `uvmunmap()` 是一致的, 只需要将 PTE 不存在和无效的两种情况由引发 panic 改为 continue 跳过即可。

    ```
    int
    uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)
    {
      pte_t *pte;
      uint64 pa, i;
      uint flags;
      char *mem;
    
      for(i = 0; i < sz; i += PGSIZE){
        if((pte = walk(old, i, 0)) == 0) 
          continue;     // new code
    //    panic("uvmcopy: pte should exist"); 
        
        if((*pte & PTE_V) == 0) 
          continue;      // new code
    //    panic("uvmcopy: page not present");
        
        // ...
    }
    ```

+ 处理用户栈下面的无效页面上发生的错误和内存不足

    修改`kernel/traps.c`的`usertrap()`，对虚拟地址超过进程大小或低于用户栈的情况进行处理，如果超出了合法范围，则杀死进程；如果在页面错误处理程序中执行`kalloc()`失败，则也杀死当前进程。

    ```
    void
    usertrap(void)
    {
      ......
    //new code
      else if (r_scause() == 13 || r_scause() == 15){
        char *pa;
     uint64 va = r_stval();
        // 虚拟地址超过 `p->sz` 或低于用户栈时，杀死进程
        if(va >= p->sz){
          printf("usertrap(): invalid va=%p higher than p->sz=%p\n",
                 va, p->sz);
          p->killed = 1;
          goto end;
        }
        if(va < PGROUNDUP(p->trapframe->sp)) {  // new code
          printf("usertrap(): invalid va=%p below the user stack sp=%p\n",
                 va, p->trapframe->sp);
          p->killed = 1;
          goto end;
        }
        if ((pa = kalloc()) == 0) {
            printf("usertrap(): kalloc() failed\n");
            p->killed = 1;
            goto end;
        }
        memset(pa, 0, PGSIZE);
        if (mappages(p->pagetable, PGROUNDDOWN(va), PGSIZE, (uint64) pa, PTE_W | PTE_R | PTE_U) != 0) {
            kfree(pa);
            printf("usertrap(): mappages() failed\n");
            p->killed = 1;
            goto end;
        }
      } else if((which_dev = devintr()) != 0){
        // ok
      } else {
        printf("usertrap(): unexpected scause %p pid=%d\n", r_scause(), p->pid);
        printf("            sepc=%p stval=%p\n", r_sepc(), r_stval());
        p->killed = 1;
      }
      end:    //new code
      if(p->killed)
        exit(-1);
    
      // give up the CPU if this is a timer interrupt.
      if(which_dev == 2)
        yield();
    
      usertrapret();
    }
    ```

+ 当 `read()`/`write()` 使用未分配物理内存时

    这两个函数最终会调用 `copyin()` 和 `copyout()` 来完成用户空间到内核空间的读写，而这两个函数最终是调用`walkaddr()` 函数来得到物理地址从而处理虚拟地址 `va` 的。

    在原本的逻辑下，PTE无效、不存在，PTE_U标志位缺失都属于失败情况。但是在lazy allocation 的情况下，上述的情况都是被允许的，现在要对它们进行处理。

    首先要判断虚拟地址 `va` 是否在用户堆空间的范围内，因为lazy allocation是针对用户的堆空间的。在这个前提下，再考虑如何分配内存，参考 `usertrap()` 中的处理，为虚拟地址分配相应的物理页面。

    修改`kernel/vm.c`的`walkaddr`函数

    ```
    uint64
    walkaddr(pagetable_t pagetable, uint64 va)
    {
      pte_t *pte;
      uint64 pa;
      struct proc *p=myproc();  // lab5-3
    
      if(va >= MAXVA)
        return 0;
    
      pte = walk(pagetable, va, 0);
      // lazy allocation
      if(pte == 0 || (*pte & PTE_V) == 0) {
        // va在用户的堆空间内
        if(va >= PGROUNDUP(p->trapframe->sp) && va < p->sz){
            char *pa;
            if ((pa = kalloc()) == 0) {
                return 0;
            }
            memset(pa, 0, PGSIZE);
            if (mappages(p->pagetable, PGROUNDDOWN(va), PGSIZE,
                         (uint64) pa, PTE_W | PTE_R | PTE_U) != 0) {
                kfree(pa);
                return 0;
            }
        } else {
            return 0;
        }
      }
      if((*pte & PTE_U) == 0)
        return 0;
      pa = PTE2PA(*pte);
      return pa;
    }
    
    ```

#### 2.2. 程序测试

启动xv6，输入`lazytests`，进行测试

```
$ lazytests
lazytests starting
running test lazy alloc
test lazy alloc: OK
running test lazy unmap
usertrap(): invalid va=0x0000000000004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x0000000001004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x0000000002004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x0000000003004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x0000000004004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x0000000005004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x0000000006004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x0000000007004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x0000000008004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x0000000009004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x000000000a004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x000000000b004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x000000000c004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x000000000d004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x000000000e004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x000000000f004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x0000000010004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x0000000011004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x0000000012004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x0000000013004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x0000000014004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x0000000015004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x0000000016004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x0000000017004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x0000000018004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x0000000019004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x000000001a004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x000000001b004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x000000001c004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x000000001d004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x000000001e004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x000000001f004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x0000000020004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x0000000021004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x0000000022004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x0000000023004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x0000000024004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x0000000025004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x0000000026004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x0000000027004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x0000000028004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x0000000029004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x000000002a004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x000000002b004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x000000002c004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x000000002d004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x000000002e004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x000000002f004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x0000000030004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x0000000031004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x0000000032004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x0000000033004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x0000000034004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x0000000035004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x0000000036004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x0000000037004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x0000000038004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x0000000039004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x000000003a004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x000000003b004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x000000003c004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x000000003d004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x000000003e004000 higher than p->sz=0x0000000000003000
usertrap(): invalid va=0x000000003f004000 higher than p->sz=0x0000000000003000
test lazy unmap: OK
running test out of memory
usertrap(): invalid va=0xffffffff80003808 higher than p->sz=0x0000000081003810
test out of memory: OK
ALL TESTS PASSED
$
```

### 3. 注意事项与提示

- 处理`sbrk()`参数为负的情况。
- 如果某个进程在高于`sbrk()`分配的任何虚拟内存地址上出现页错误，则终止该进程。
- 在`fork()`中正确处理父到子内存拷贝。
- 处理这种情形：进程从`sbrk()`向系统调用（如`read`或`write`）传递有效地址，但尚未分配该地址的内存。
- 正确处理内存不足：如果在页面错误处理程序中执行`kalloc()`失败，则终止当前进程。
- 处理用户栈下面的无效页面上发生的错误。

如果内核通过`lazytests`和`usertests`，那么您的解决方案是可以接受的：

## 四. 总实验结果

在目录下创建`time.txt`，并输入完成实验的小时数。在终端执行

```
 ./grade-lab-lazy
```

来对实验结果进行完全测试。

测试结果如下：

```
make: 'kernel/kernel' is up to date.
== Test running lazytests == (3.4s)
== Test   lazy: map ==
  lazy: map: OK
== Test   lazy: unmap ==
  lazy: unmap: OK
== Test usertests == (118.3s)
== Test   usertests: pgbug ==
  usertests: pgbug: OK
== Test   usertests: sbrkbugs ==
  usertests: sbrkbugs: OK
== Test   usertests: argptest ==
  usertests: argptest: OK
== Test   usertests: sbrkmuch ==
  usertests: sbrkmuch: OK
== Test   usertests: sbrkfail ==
  usertests: sbrkfail: OK
== Test   usertests: sbrkarg ==
  usertests: sbrkarg: OK
== Test   usertests: stacktest ==
  usertests: stacktest: OK
== Test   usertests: execout ==
  usertests: execout: OK
== Test   usertests: copyin ==
  usertests: copyin: OK
== Test   usertests: copyout ==
  usertests: copyout: OK
== Test   usertests: copyinstr1 ==
  usertests: copyinstr1: OK
== Test   usertests: copyinstr2 ==
  usertests: copyinstr2: OK
== Test   usertests: copyinstr3 ==
  usertests: copyinstr3: OK
== Test   usertests: rwsbrk ==
  usertests: rwsbrk: OK
== Test   usertests: truncate1 ==
  usertests: truncate1: OK
== Test   usertests: truncate2 ==
  usertests: truncate2: OK
== Test   usertests: truncate3 ==
  usertests: truncate3: OK
== Test   usertests: reparent2 ==
  usertests: reparent2: OK
== Test   usertests: badarg ==
  usertests: badarg: OK
== Test   usertests: reparent ==
  usertests: reparent: OK
== Test   usertests: twochildren ==
  usertests: twochildren: OK
== Test   usertests: forkfork ==
  usertests: forkfork: OK
== Test   usertests: forkforkfork ==
  usertests: forkforkfork: OK
== Test   usertests: createdelete ==
  usertests: createdelete: OK
== Test   usertests: linkunlink ==
  usertests: linkunlink: OK
== Test   usertests: linktest ==
  usertests: linktest: OK
== Test   usertests: unlinkread ==
  usertests: unlinkread: OK
== Test   usertests: concreate ==
  usertests: concreate: OK
== Test   usertests: subdir ==
  usertests: subdir: OK
== Test   usertests: fourfiles ==
  usertests: fourfiles: OK
== Test   usertests: sharedfd ==
  usertests: sharedfd: OK
== Test   usertests: exectest ==
  usertests: exectest: OK
== Test   usertests: bigargtest ==
  usertests: bigargtest: OK
== Test   usertests: bigwrite ==
  usertests: bigwrite: OK
== Test   usertests: bsstest ==
  usertests: bsstest: OK
== Test   usertests: sbrkbasic ==
  usertests: sbrkbasic: OK
== Test   usertests: kernmem ==
  usertests: kernmem: OK
== Test   usertests: validatetest ==
  usertests: validatetest: OK
== Test   usertests: opentest ==
  usertests: opentest: OK
== Test   usertests: writetest ==
  usertests: writetest: OK
== Test   usertests: writebig ==
  usertests: writebig: OK
== Test   usertests: createtest ==
  usertests: createtest: OK
== Test   usertests: openiput ==
  usertests: openiput: OK
== Test   usertests: exitiput ==
  usertests: exitiput: OK
== Test   usertests: iput ==
  usertests: iput: OK
== Test   usertests: mem ==
  usertests: mem: OK
== Test   usertests: pipe1 ==
  usertests: pipe1: OK
== Test   usertests: preempt ==
  usertests: preempt: OK
== Test   usertests: exitwait ==
  usertests: exitwait: OK
== Test   usertests: rmdot ==
  usertests: rmdot: OK
== Test   usertests: fourteen ==
  usertests: fourteen: OK
== Test   usertests: bigfile ==
  usertests: bigfile: OK
== Test   usertests: dirfile ==
  usertests: dirfile: OK
== Test   usertests: iref ==
  usertests: iref: OK
== Test   usertests: forktest ==
  usertests: forktest: OK
== Test time ==
time: OK
Score: 119/119
```

## 五. 遇到的问题以及解决方法

编写好代码，启动xv6，报错如下：

```
kernel/vm.c: In function ‘walkaddr’:
kernel/vm.c:108:25: error: dereferencing pointer to incomplete type ‘struct proc’
```

在`vm.c`中引入头文件`proc.h`后启动`make qemu`报错如下：

```
kernel/proc.h:87:19: error: field ‘lock’ has incomplete type
   87 |   struct spinlock lock;
```

检查后发现，报错原因是头文件中重复包含了`struct spinlock lock`的定义，解决方法是在头文件中引入`#include "spinlock.h"`，引入后不再报错。



# Lab6. Copy-on-Write Fork for xv6

## 一. Implement copy-on write([hard](https://pdos.csail.mit.edu/6.828/2020/labs/guidance.html))

### 1. 实验要求

xv6中的`fork()`系统调用将父进程的所有用户空间内存复制到子进程中。如果父进程较大，则复制可能需要很长时间。更糟糕的是，这项工作经常造成大量浪费；例如，子进程中的`fork()`后跟`exec()`将导致子进程丢弃复制的内存，而其中的大部分可能都从未使用过。另一方面，如果父子进程都使用一个页面，并且其中一个或两个对该页面有写操作，则确实需要复制。

copy-on-write (COW) fork()的目标是推迟到子进程实际需要物理内存拷贝时再进行分配和复制物理内存页面。

COW fork()只为子进程创建一个页表，用户内存的PTE指向父进程的物理页。COW fork()将父进程和子进程中的所有用户PTE标记为不可写。当任一进程试图写入其中一个COW页时，CPU将强制产生页面错误。内核页面错误处理程序检测到这种情况将为出错进程分配一页物理内存，将原始页复制到新页中，并修改出错进程中的相关PTE指向新的页面，将PTE标记为可写。当页面错误处理程序返回时，用户进程将能够写入其页面副本。

COW fork()将使得释放用户内存的物理页面变得更加棘手。给定的物理页可能会被多个进程的页表引用，并且只有在最后一个引用消失时才应该被释放。

您的任务是在xv6内核中实现copy-on-write fork。如果修改后的内核同时成功执行`cowtest`和`usertests`程序就完成了。

### 2. 实验步骤

#### 2.1. 编写代码并配置

+ 为了实现COW机制，我们需要对物理内存分配器进行修改。在COW中，一个物理页面可能被多个页表引用，因此我们需要引入一个数据结构来跟踪页面的引用计数。

    ```
    //kalloc.c
    struct spinlock reflock;
    uint8 referencecount[PHYSTOP/PGSIZE];
    ```

+ 在初始化内存管理器的` kinit` 中添加初始化引用计数锁的语句，并更改释放物理页面的代码，使得每次释放仅将引用计数减一，直到引用计数为 0 后才真正释放页面。

    ```
    //kalloc.c
    void
    kinit()
    {
      initlock(&kmem.lock, "kmem");
      initlock(&reflock, "ref");
      freerange(end, (void*)PHYSTOP);
    }
    
    void
    freerange(void *pa_start, void *pa_end)
    {
      char *p;
      p = (char*)PGROUNDUP((uint64)pa_start);
      for(; p + PGSIZE <= (char*)pa_end; p += PGSIZE)
      {
        acquire(&reflock);
        referencecount[(uint64)p / PGSIZE] = 0;
        release(&reflock);
        
        kfree(p);
      }
    }
    ```

+ 将父进程的页面映射给子进程，并给父进程和子进程的页表设为只读。

    修改` vm.c` 中的 `uvmcopy` 使用 `mappages `只映射页面、增加引用计数并修改权限为只读，而不分配页面，这里使用了分页机制中为软件使用保留的第 8 位作为标志位，若其为 1 ，则说明其为 COW页。

    ```
    vm.c
    int
    uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)
    {
      pte_t *pte;
      uint64 pa, i;
      uint flags;
      // char *mem;
    
      for(i = 0; i < sz; i += PGSIZE){
        if((pte = walk(old, i, 0)) == 0)
          panic("uvmcopy: pte should exist");
        if((*pte & PTE_V) == 0)
          panic("uvmcopy: page not present");
        *pte &= ~(PTE_W);
        *pte |= PTE_COW;
        pa = PTE2PA(*pte);
        flags = PTE_FLAGS(*pte);
        // if((mem = kalloc()) == 0)
        //   goto err;
        // memmove(mem, (char*)pa, PGSIZE);
        // if(mappages(new, i, PGSIZE, (uint64)mem, flags) != 0){
        //   kfree(mem);
        //   goto err;
        // }
        if(mappages(new, i, PGSIZE, (uint64)pa, flags) != 0){
          goto err;
        }
        // printf("uvmcopy: lazy copying va=%p pa=%p\n",i,pa);
        acquire(&reflock);
        referencecount[PGROUNDUP((uint64)pa)/PGSIZE]++;
        release(&reflock);
      }
      return 0;
    
     err:
      uvmunmap(new, 0, i / PGSIZE, 1);
      return -1;
    }
    
    ```

+ 通过引入 `uvmcopy` 操作，我们引入了对页面的引用计数。在删除页面映射的过程` uvmunmap `中，我们也需要添加相应的操作来保持引用计数的正确性。这样，我们就完成了写时复制（COW）机制的前半部分。如果父进程和子进程在 fork 后都没有尝试写入内存，那么一切都会平稳进行。然而，如果其中一个进程尝试写入内存，就会触发页面权限错误，从而引发中断并最终调用 `usertrap `函数。这个机制可以确保写入操作不会对其他进程产生影响，从而保证进程之间的数据隔离性。

    ```
    //vm.c
    extern struct spinlock reflock;
    extern uint8 referencecount[PHYSTOP/PGSIZE];
    void
    uvmunmap(pagetable_t pagetable, uint64 va, uint64 npages, int do_free)
    {
      uint64 a;
      pte_t *pte;
    
      if((va % PGSIZE) != 0)
        panic("uvmunmap: not aligned");
    
      for(a = va; a < va + npages*PGSIZE; a += PGSIZE){
        if((pte = walk(pagetable, a, 0)) == 0)
          panic("uvmunmap: walk");
        if((*pte & PTE_V) == 0)
          panic("uvmunmap: not mapped");
        if(PTE_FLAGS(*pte) == PTE_V)
          panic("uvmunmap: not a leaf");
        acquire(&reflock);
        referencecount[PGROUNDUP((PTE2PA(*pte)))/PGSIZE]--;
        if(do_free && referencecount[PGROUNDUP((PTE2PA(*pte)))/PGSIZE] < 1){
        // if(do_free){
          uint64 pa = PTE2PA(*pte);
          kfree((void*)pa);
        }
        release(&reflock);
        *pte = 0;
      }
    }
    ```

+ 当发生写页面权限引起的错误时，会导致SCAUSE寄存器被设置为12或15，而STVAL寄存器中将存储导致违反权限的虚拟内存地址。通过使用riscv.h中提供的读取寄存器函数，我们可以获取这两个寄存器的内容。如果违例访问是由COW机制引起的，我们可以进行以下工作：分配新页面、复制数据、释放旧页面、修改页面权限和标志等。如果不是COW引起的违例访问，我们需要终止进程并进行相应的清理工作。

    ```
    //trap.c
    extern uint8 referencecount[PHYSTOP/PGSIZE];
    void
    usertrap(void)
    {
      int which_dev = 0;
    
      if((r_sstatus() & SSTATUS_SPP) != 0)
        panic("usertrap: not from user mode");
    
      // send interrupts and exceptions to kerneltrap(),
      // since we're now in the kernel.
      w_stvec((uint64)kernelvec);
    
      struct proc *p = myproc();
      
      // save user program counter.
      p->trapframe->epc = r_sepc();
      
      if(r_scause() == 8){
        // system call
    
        if(p->killed)
          exit(-1);
    
        // sepc points to the ecall instruction,
        // but we want to return to the next instruction.
        p->trapframe->epc += 4;
    
        // an interrupt will change sstatus &c registers,
        // so don't enable until done with those registers.
        intr_on();
    
        syscall();
      } else if((which_dev = devintr()) != 0){
        // ok
      } else if (r_scause() == 12 || r_scause() == 15){
        // deal with cow pages
        pte_t *pte;
        uint64 pa, va;
        // uint64 va;
        uint flags;
        char *mem;
    
        va = r_stval();
        if(va >= MAXVA)
        {
          p->killed = 1;
          exit(-1);
        }
          
        if((pte = walk(p->pagetable, va, 0)) == 0)
        {
          // panic("cowhandler: pte should exist");
          p->killed = 1;
          exit(-1);
        }
        if((*pte & PTE_V) == 0)
        {
          // panic("cowhandler: page not present");
          p->killed = 1;
          exit(-1);
        }
        if((*pte & PTE_COW) == 0)
        {
          // panic("cowhandler: page not cow");
          p->killed = 1;
          exit(-1);
        }
    
        pa = PTE2PA(*pte);
        flags = PTE_FLAGS(*pte) | PTE_W;
        flags &= ~(PTE_COW);
        // printf("cowhandler: scause=%d va=%p pa=%p\n",r_scause(),va,pa);
        if((mem = kalloc()) == 0)
        {
          // printf("%d: cowhandler: kalloc failed, killed the process\n",p->pid);
          p->killed = 1;
          exit(-1);
        }
        // printf("%d: cowhandler: kalloc succeeded with pa=%p\n",p->pid,mem);
        // printf("%d: cowhandler: uvmunmap succeeded with va=%p\n",p->pid,PGROUNDDOWN(va));
        memmove(mem, (char*)pa, PGSIZE);
        uvmunmap(p->pagetable, PGROUNDDOWN(va), 1, 1);
        // printf("%d: cowhandler: memmove succeeded with from pa=%p to mem=%p\n",p->pid,pa,mem);
        // if(mappages(p->pagetable, va, PGSIZE, (uint64)mem, flags) != 0){   
        if(mappages(p->pagetable, PGROUNDDOWN(va), PGSIZE, (uint64)mem, flags) != 0){
          kfree(mem);
          panic("cowhandler: mappages failed");
        }
      }
      else {
        printf("usertrap(): unexpected scause %p pid=%d\n", r_scause(), p->pid);
        printf("            sepc=%p stval=%p\n", r_sepc(), r_stval());
        p->killed = 1;
      }
    
      if(p->killed)
        exit(-1);
    
      // give up the CPU if this is a timer interrupt.
      if(which_dev == 2)
        yield();
    
      usertrapret();
    }
    ```

+ 需要修改 copyout() 函数以适应COW机制。 copyout() 函数在内核态修改用户态的页面内存，不会引发从用户态来的权限违例。因此，在处理COW页面时需要进行特殊处理。

    ```
    //vm.c
    int
    copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)
    {
      uint64 n, va0, pa0;
      pte_t *pte;
      while(len > 0){
        va0 = PGROUNDDOWN(dstva);
        pa0 = walkaddr(pagetable, va0);
        if(dstva >= MAXVA)
          return -1;
        pte = walk(pagetable, va0, 0);
        if(pa0 == 0)
          return -1;
        n = PGSIZE - (dstva - va0);
        if(n > len)
          n = len;
        if (*pte & PTE_COW)
        {
          uint flags;
          char *mem;
          flags = PTE_FLAGS(*pte) | PTE_W;
          flags &= ~(PTE_COW);
          if((mem = kalloc()) == 0)
          {
            // printf("copyout: kalloc failed, killed the process\n");
            return -1;
          }
          memmove(mem, (char*)pa0, PGSIZE);
          uvmunmap(pagetable, va0, 1, 1);
          if(mappages(pagetable, va0, PGSIZE, (uint64)mem, flags) != 0)
          {
            kfree(mem);
            panic("copyout: mappages failed");
          }
        }
        pa0 = walkaddr(pagetable, va0);
        memmove((void *)(pa0 + (dstva - va0)), src, n);
    
        len -= n;
        src += n;
        dstva = va0 + PGSIZE;
      }
      return 0;
    }
    ```

#### 2.2. 程序测试

启动xv6，输入`cowtest`，进行测试

```
$ cowtest
simple: ok
simple: ok
three: ok
three: ok
three: ok
file: ok
ALL COW TESTS PASSED
$
```

输入`usertests`，进行测试

```
$ usertests
usertests starting
test execout: OK
test copyin: OK
test copyout: OK
test copyinstr1: OK
test copyinstr2: OK
test copyinstr3: OK
test rwsbrk: OK
test truncate1: OK
test truncate2: OK
test truncate3: OK
test reparent2: OK
test pgbug: OK
test sbrkbugs: OK
test badarg: OK
test reparent: OK
test twochildren: OK
test forkfork: OK
test forkforkfork: OK
test argptest: OK
test createdelete: OK
test linkunlink: OK
test linktest: OK
test unlinkread: OK
test concreate: OK
test subdir: OK
test fourfiles: OK
test sharedfd: OK
test dirtest: OK
test exectest: OK
test bigargtest: OK
test bigwrite: OK
test bsstest: OK
test sbrkbasic: OK
test sbrkmuch: OK
test kernmem: usertrap(): unexpected scause 0x000000000000000d pid=6225
            sepc=0x0000000000002026 stval=0x0000000080000000
usertrap(): unexpected scause 0x000000000000000d pid=6226
            sepc=0x0000000000002026 stval=0x000000008000c350
usertrap(): unexpected scause 0x000000000000000d pid=6227
            sepc=0x0000000000002026 stval=0x00000000800186a0
usertrap(): unexpected scause 0x000000000000000d pid=6228
            sepc=0x0000000000002026 stval=0x00000000800249f0
usertrap(): unexpected scause 0x000000000000000d pid=6229
            sepc=0x0000000000002026 stval=0x0000000080030d40
usertrap(): unexpected scause 0x000000000000000d pid=6230
            sepc=0x0000000000002026 stval=0x000000008003d090
usertrap(): unexpected scause 0x000000000000000d pid=6231
            sepc=0x0000000000002026 stval=0x00000000800493e0
usertrap(): unexpected scause 0x000000000000000d pid=6232
            sepc=0x0000000000002026 stval=0x0000000080055730
usertrap(): unexpected scause 0x000000000000000d pid=6233
            sepc=0x0000000000002026 stval=0x0000000080061a80
usertrap(): unexpected scause 0x000000000000000d pid=6234
            sepc=0x0000000000002026 stval=0x000000008006ddd0
usertrap(): unexpected scause 0x000000000000000d pid=6235
            sepc=0x0000000000002026 stval=0x000000008007a120
usertrap(): unexpected scause 0x000000000000000d pid=6236
            sepc=0x0000000000002026 stval=0x0000000080086470
usertrap(): unexpected scause 0x000000000000000d pid=6237
            sepc=0x0000000000002026 stval=0x00000000800927c0
usertrap(): unexpected scause 0x000000000000000d pid=6238
            sepc=0x0000000000002026 stval=0x000000008009eb10
usertrap(): unexpected scause 0x000000000000000d pid=6239
            sepc=0x0000000000002026 stval=0x00000000800aae60
usertrap(): unexpected scause 0x000000000000000d pid=6240
            sepc=0x0000000000002026 stval=0x00000000800b71b0
usertrap(): unexpected scause 0x000000000000000d pid=6241
            sepc=0x0000000000002026 stval=0x00000000800c3500
usertrap(): unexpected scause 0x000000000000000d pid=6242
            sepc=0x0000000000002026 stval=0x00000000800cf850
usertrap(): unexpected scause 0x000000000000000d pid=6243
            sepc=0x0000000000002026 stval=0x00000000800dbba0
usertrap(): unexpected scause 0x000000000000000d pid=6244
            sepc=0x0000000000002026 stval=0x00000000800e7ef0
usertrap(): unexpected scause 0x000000000000000d pid=6245
            sepc=0x0000000000002026 stval=0x00000000800f4240
usertrap(): unexpected scause 0x000000000000000d pid=6246
            sepc=0x0000000000002026 stval=0x0000000080100590
usertrap(): unexpected scause 0x000000000000000d pid=6247
            sepc=0x0000000000002026 stval=0x000000008010c8e0
usertrap(): unexpected scause 0x000000000000000d pid=6248
            sepc=0x0000000000002026 stval=0x0000000080118c30
usertrap(): unexpected scause 0x000000000000000d pid=6249
            sepc=0x0000000000002026 stval=0x0000000080124f80
usertrap(): unexpected scause 0x000000000000000d pid=6250
            sepc=0x0000000000002026 stval=0x00000000801312d0
usertrap(): unexpected scause 0x000000000000000d pid=6251
            sepc=0x0000000000002026 stval=0x000000008013d620
usertrap(): unexpected scause 0x000000000000000d pid=6252
            sepc=0x0000000000002026 stval=0x0000000080149970
usertrap(): unexpected scause 0x000000000000000d pid=6253
            sepc=0x0000000000002026 stval=0x0000000080155cc0
usertrap(): unexpected scause 0x000000000000000d pid=6254
            sepc=0x0000000000002026 stval=0x0000000080162010
usertrap(): unexpected scause 0x000000000000000d pid=6255
            sepc=0x0000000000002026 stval=0x000000008016e360
usertrap(): unexpected scause 0x000000000000000d pid=6256
            sepc=0x0000000000002026 stval=0x000000008017a6b0
usertrap(): unexpected scause 0x000000000000000d pid=6257
            sepc=0x0000000000002026 stval=0x0000000080186a00
usertrap(): unexpected scause 0x000000000000000d pid=6258
            sepc=0x0000000000002026 stval=0x0000000080192d50
usertrap(): unexpected scause 0x000000000000000d pid=6259
            sepc=0x0000000000002026 stval=0x000000008019f0a0
usertrap(): unexpected scause 0x000000000000000d pid=6260
            sepc=0x0000000000002026 stval=0x00000000801ab3f0
usertrap(): unexpected scause 0x000000000000000d pid=6261
            sepc=0x0000000000002026 stval=0x00000000801b7740
usertrap(): unexpected scause 0x000000000000000d pid=6262
            sepc=0x0000000000002026 stval=0x00000000801c3a90
usertrap(): unexpected scause 0x000000000000000d pid=6263
            sepc=0x0000000000002026 stval=0x00000000801cfde0
usertrap(): unexpected scause 0x000000000000000d pid=6264
            sepc=0x0000000000002026 stval=0x00000000801dc130
OK
test sbrkfail: usertrap(): unexpected scause 0x000000000000000d pid=6276
            sepc=0x00000000000040c6 stval=0x0000000000012000
OK
test sbrkarg: OK
test validatetest: OK
test stacktest: usertrap(): unexpected scause 0x000000000000000d pid=6280
            sepc=0x0000000000002196 stval=0x000000000000fba0
OK
test opentest: OK
test writetest: OK
test writebig: OK
test createtest: OK
test openiput: OK
test exitiput: OK
test iput: OK
test mem: OK
test pipe1: OK
test preempt: kill... wait... OK
test exitwait: OK
test rmdot: OK
test fourteen: OK
test bigfile: OK
test dirfile: OK
test iref: OK
test forktest: OK
test bigdir: OK
ALL TESTS PASSED
$
```

### 3. 注意事项与提示

为了帮助测试你的实现方案，我们提供了一个名为`cowtest`的xv6程序（源代码位于***user/cowtest.c***）。`cowtest`运行各种测试，但在未修改的xv6上，即使是第一个测试也会失败。因此，最初您将看到：

````bash
$ cowtest
simple: fork() failed
$
````

“simple”测试分配超过一半的可用物理内存，然后执行一系列的`fork()`。`fork`失败的原因是没有足够的可用物理内存来为子进程提供父进程内存的完整副本。

完成本实验后，内核应该通过`cowtest`和`usertests`中的所有测试。即：

````bash
$ cowtest
simple: ok
simple: ok
three: zombie!
ok
three: zombie!
ok
three: zombie!
ok
file: ok
ALL COW TESTS PASSED
$ usertests
...
ALL TESTS PASSED
$
````

**一个合理的攻克计划：**

1. **修改`uvmcopy()`将父进程的物理页映射到子进程**，而不是分配新页。在子进程和父进程的PTE中清除`PTE_W`标志。
2. **修改`usertrap()`以识别页面错误**。当COW页面出现页面错误时，使用`kalloc()`分配一个新页面，并将旧页面复制到新页面，然后将新页面添加到PTE中并设置`PTE_W`。
3. **确保每个物理页在最后一个PTE对它的引用撤销时被释放**——而不是在此之前。这样做的一个好方法是为每个物理页保留引用该页面的用户页表数的“引用计数”。当`kalloc()`分配页时，将页的引用计数设置为1。当`fork`导致子进程共享页面时，增加页的引用计数；每当任何进程从其页表中删除页面时，减少页的引用计数。`kfree()`只应在引用计数为零时将页面放回空闲列表。可以将这些计数保存在一个固定大小的整型数组中。你必须制定一个如何索引数组以及如何选择数组大小的方案。例如，您可以用页的物理地址除以4096对数组进行索引，并为数组提供等同于***kalloc.c***中`kinit()`在空闲列表中放置的所有页面的最高物理地址的元素数。
4. **修改`copyout()`在遇到COW页面时使用与页面错误相同的方案。**

**提示**

- lazy page allocation实验可能已经让您熟悉了许多与`copy-on-write`相关的xv6内核代码。但是，您不应该将这个实验室建立在您的lazy allocation解决方案的基础上；相反，请按照上面的说明从一个新的xv6开始。
- 有一种可能很有用的方法来记录每个PTE是否是COW映射。您可以使用RISC-V PTE中的RSW（reserved for software，即为软件保留的）位来实现此目的。
- `usertests`检查`cowtest`不测试的场景，所以别忘两个测试都需要完全通过。
- `kernel/riscv.h`的末尾有一些有用的宏和页表标志位的定义。
- 如果出现COW页面错误并且没有可用内存，则应终止进程。

## 二. 总实验结果

在目录下创建`time.txt`，并输入完成实验的小时数。在终端执行

```
 ./grade-lab-cow
```

来对实验结果进行完全测试。

测试结果如下：

```
make: 'kernel/kernel' is up to date.
== Test running cowtest == (6.8s)
== Test   simple ==
  simple: OK
== Test   three ==
  three: OK
== Test   file ==
  file: OK
== Test usertests == (154.4s)
== Test   usertests: copyin ==
  usertests: copyin: OK
== Test   usertests: copyout ==
  usertests: copyout: OK
== Test   usertests: all tests ==
  usertests: all tests: OK
== Test time ==
time: OK
Score: 110/110
```

## 三. 遇到的问题以及解决方法

如何标记页面为COW页面，使得父子进程可以共享页面但保证数据不被破坏？

解决方法：通过在页表项中设置特定的标志位，例如在 PTE_FLAGS 中添加一个标志位表示页面是COW页面。这样父子进程可以共享页面，但在写入时会触发中断，从而进行相应处理。



# Lab7. Multithreading

## 一. Uthread: switching between threads ([moderate](https://pdos.csail.mit.edu/6.828/2020/labs/guidance.html))

### 1. 实验要求

在本练习中，您将为用户级线程系统设计上下文切换机制，然后实现它。为了让您开始，您的xv6有两个文件：`user/uthread.c`和`user/uthread_switch.S`，以及一个规则：运行在`Makefile`中以构建`uthread`程序。`uthread.c`包含大多数用户级线程包，以及三个简单测试线程的代码。线程包缺少一些用于创建线程和在线程之间切换的代码。

本次实验中需要提出一个创建线程和保存/恢复寄存器以在线程之间切换的计划，并实现该计划。

### 2. 实验步骤

#### 2.1. 编写代码及配置

+ 设置线程上下文的结构体

    参考了 `kernel/proc.h` 中定义的 `struct context` 结构体，在`user/uthread.c`设计了`struct ctx` 结构体

    ```
    struct ctx {
        uint64 ra;
        uint64 sp;
    
        // callee-saved
        uint64 s0;
        uint64 s1;
        uint64 s2;
        uint64 s3;
        uint64 s4;
        uint64 s5;
        uint64 s6;
        uint64 s7;
        uint64 s8;
        uint64 s9;
        uint64 s10;
        uint64 s11;
    };
    ```

+ 为线程结构体添加上下文字段

    线程上下文结构体`struct context`和线程是一一对应的，可以直接成为线程结构体的一个数据成员。

    ```
    struct thread {
      char       stack[STACK_SIZE]; /* the thread's stack */
      int        state;             /* FREE, RUNNING, RUNNABLE */
      struct ctx context;       // 线程上下文
    };
    ```

+ 修改 `thread_create()` 函数

    它主要负责线程的初始化操作，在线程数组中遍历，发现一个未初始化的线程，再执行一系列包括状态设置为 `RUNNABLE` 的初始化操作。

    ```
    void 
    thread_create(void (*func)()){
      struct thread *t;
    
      for (t = all_thread; t < all_thread + MAX_THREAD; t++) {
        if (t->state == FREE) break;
      }
      t->state = RUNNABLE;
      // new code
      // 初始化上下文字段
      t->context.ra = (uint64) func;
      t->context.sp = (uint64) t->stack + STACK_SIZE;
    }
    ```

+ 修改 `thread_schedule()` 函数

    它负责负责用户多线程间的调度。它从当前线程的位置开始，在线程数组中寻找一个 `RUNNABLE` 状态的线程进行运行，在找到线程后调用函数 `thread_switch()`进行线程的切换。

    下面先修改 `thread_schedule()` 函数

    ```
    void 
    thread_schedule(void)
    {
      struct thread *t, *next_thread;
    
      /* Find another runnable thread. */
      next_thread = 0;
      t = current_thread + 1;
      for(int i = 0; i < MAX_THREAD; i++){
        if(t >= all_thread + MAX_THREAD)
          t = all_thread;
        if(t->state == RUNNABLE) {
          next_thread = t;
          break;
        }
        t = t + 1;
      }
    
      if (next_thread == 0) {
        printf("thread_schedule: no runnable threads\n");
        exit(-1);
      }
    
      if (current_thread != next_thread) {       
        next_thread->state = RUNNING;
        t = current_thread;
        current_thread = next_thread;
    	//new code
        //切换线程
        thread_switch(&t->context, &current_thread->context);   
      } else
        next_thread = 0;
    }
    ```

+ 实现 `thread_switch` 

    它的功能和 `kernel/switch.S` 中的 `switch` 函数一致，并且线程结构体成员也相同，可以直接参考 `switch` 代码。在 `user/uthread_switch.S` 实现 `thread_switch` 。

    ```
    	.text
    
    	/*
         * save the old thread's registers,
         * restore the new thread's registers.
         */
    
    	.globl thread_switch
    thread_switch:
    	/* new code */
    	# same as swtch in swtch.S - lab7
        sd ra, 0(a0)
        sd sp, 8(a0)
        sd s0, 16(a0)
        sd s1, 24(a0)
        sd s2, 32(a0)
        sd s3, 40(a0)
        sd s4, 48(a0)
        sd s5, 56(a0)
        sd s6, 64(a0)
        sd s7, 72(a0)
        sd s8, 80(a0)
        sd s9, 88(a0)
        sd s10, 96(a0)
        sd s11, 104(a0)
    
        ld ra, 0(a1)
        ld sp, 8(a1)
        ld s0, 16(a1)
        ld s1, 24(a1)
        ld s2, 32(a1)
        ld s3, 40(a1)
        ld s4, 48(a1)
        ld s5, 56(a1)
        ld s6, 64(a1)
        ld s7, 72(a1)
        ld s8, 80(a1)
        ld s9, 88(a1)
        ld s10, 96(a1)
        ld s11, 104(a1)
    	ret    /* return to ra */
    
    ```

#### 2.2. 程序测试

启动xv6,，输入指令`uthread`

```
$ uthread
thread_a started
thread_b started
thread_c started
thread_c 0
thread_a 0
thread_b 0
thread_c 1
thread_a 1
thread_b 1
thread_c 2
thread_a 2
thread_b 2
thread_c 3
thread_a 3
thread_b 3
thread_c 4
thread_a 4
thread_b 4
thread_c 5
thread_a 5
thread_b 5
thread_c 6
thread_a 6
thread_b 6
thread_c 7
thread_a 7
thread_b 7
thread_c 8
thread_a 8
thread_b 8
thread_c 9
thread_a 9
thread_b 9
thread_c 10
thread_a 10
thread_b 10
thread_c 11
thread_a 11
thread_b 11
thread_c 12
thread_a 12
thread_b 12
thread_c 13
thread_a 13
thread_b 13
thread_c 14
thread_a 14
thread_b 14
thread_c 15
thread_a 15
thread_b 15
thread_c 16
thread_a 16
thread_b 16
thread_c 17
thread_a 17
thread_b 17
thread_c 18
thread_a 18
thread_b 18
thread_c 19
thread_a 19
thread_b 19
thread_c 20
thread_a 20
thread_b 20
thread_c 21
thread_a 21
thread_b 21
thread_c 22
thread_a 22
thread_b 22
thread_c 23
thread_a 23
thread_b 23
thread_c 24
thread_a 24
thread_b 24
thread_c 25
thread_a 25
thread_b 25
thread_c 26
thread_a 26
thread_b 26
thread_c 27
thread_a 27
thread_b 27
thread_c 28
thread_a 28
thread_b 28
thread_c 29
thread_a 29
thread_b 29
thread_c 30
thread_a 30
thread_b 30
thread_c 31
thread_a 31
thread_b 31
thread_c 32
thread_a 32
thread_b 32
thread_c 33
thread_a 33
thread_b 33
thread_c 34
thread_a 34
thread_b 34
thread_c 35
thread_a 35
thread_b 35
thread_c 36
thread_a 36
thread_b 36
thread_c 37
thread_a 37
thread_b 37
thread_c 38
thread_a 38
thread_b 38
thread_c 39
thread_a 39
thread_b 39
thread_c 40
thread_a 40
thread_b 40
thread_c 41
thread_a 41
thread_b 41
thread_c 42
thread_a 42
thread_b 42
thread_c 43
thread_a 43
thread_b 43
thread_c 44
thread_a 44
thread_b 44
thread_c 45
thread_a 45
thread_b 45
thread_c 46
thread_a 46
thread_b 46
thread_c 47
thread_a 47
thread_b 47
thread_c 48
thread_a 48
thread_b 48
thread_c 49
thread_a 49
thread_b 49
thread_c 50
thread_a 50
thread_b 50
thread_c 51
thread_a 51
thread_b 51
thread_c 52
thread_a 52
thread_b 52
thread_c 53
thread_a 53
thread_b 53
thread_c 54
thread_a 54
thread_b 54
thread_c 55
thread_a 55
thread_b 55
thread_c 56
thread_a 56
thread_b 56
thread_c 57
thread_a 57
thread_b 57
thread_c 58
thread_a 58
thread_b 58
thread_c 59
thread_a 59
thread_b 59
thread_c 60
thread_a 60
thread_b 60
thread_c 61
thread_a 61
thread_b 61
thread_c 62
thread_a 62
thread_b 62
thread_c 63
thread_a 63
thread_b 63
thread_c 64
thread_a 64
thread_b 64
thread_c 65
thread_a 65
thread_b 65
thread_c 66
thread_a 66
thread_b 66
thread_c 67
thread_a 67
thread_b 67
thread_c 68
thread_a 68
thread_b 68
thread_c 69
thread_a 69
thread_b 69
thread_c 70
thread_a 70
thread_b 70
thread_c 71
thread_a 71
thread_b 71
thread_c 72
thread_a 72
thread_b 72
thread_c 73
thread_a 73
thread_b 73
thread_c 74
thread_a 74
thread_b 74
thread_c 75
thread_a 75
thread_b 75
thread_c 76
thread_a 76
thread_b 76
thread_c 77
thread_a 77
thread_b 77
thread_c 78
thread_a 78
thread_b 78
thread_c 79
thread_a 79
thread_b 79
thread_c 80
thread_a 80
thread_b 80
thread_c 81
thread_a 81
thread_b 81
thread_c 82
thread_a 82
thread_b 82
thread_c 83
thread_a 83
thread_b 83
thread_c 84
thread_a 84
thread_b 84
thread_c 85
thread_a 85
thread_b 85
thread_c 86
thread_a 86
thread_b 86
thread_c 87
thread_a 87
thread_b 87
thread_c 88
thread_a 88
thread_b 88
thread_c 89
thread_a 89
thread_b 89
thread_c 90
thread_a 90
thread_b 90
thread_c 91
thread_a 91
thread_b 91
thread_c 92
thread_a 92
thread_b 92
thread_c 93
thread_a 93
thread_b 93
thread_c 94
thread_a 94
thread_b 94
thread_c 95
thread_a 95
thread_b 95
thread_c 96
thread_a 96
thread_b 96
thread_c 97
thread_a 97
thread_b 97
thread_c 98
thread_a 98
thread_b 98
thread_c 99
thread_a 99
thread_b 99
thread_c: exit after 100
thread_a: exit after 100
thread_b: exit after 100
thread_schedule: no runnable threads
$
```

退出xv6进行单元测试

```bash
$ ./grade-lab-thread uthread
```

单元测试通过

```
make: 'kernel/kernel' is up to date.
== Test uthread == uthread: OK (1.8s)
```

### 3. 注意事项和提示

完成后，在xv6上运行`uthread`时应该会看到以下输出（三个线程可能以不同的顺序启动）：

````bash
$ make qemu
...
$ uthread
thread_a started
thread_b started
thread_c started
thread_c 0
thread_a 0
thread_b 0
thread_c 1
thread_a 1
thread_b 1
...
thread_c 99
thread_a 99
thread_b 99
thread_c: exit after 100
thread_a: exit after 100
thread_b: exit after 100
thread_schedule: no runnable threads
$
````

该输出来自三个测试线程，每个线程都有一个循环，该循环打印一行，然后将CPU让出给其他线程。

然而在此时还没有上下文切换的代码，您将看不到任何输出。

您需要将代码添加到`user/uthread.c`中的`thread_create()`和`thread_schedule()`，以及`user/uthread_switch.S`中的`thread_switch`。

一个目标是确保当`thread_schedule()`第一次运行给定线程时，该线程在自己的栈上执行传递给`thread_create()`的函数。
另一个目标是确保`thread_switch`保存被切换线程的寄存器，恢复切换到线程的寄存器，并返回到后一个线程指令中最后停止的点。
您必须决定保存/恢复寄存器的位置；修改`struct thread`以保存寄存器是一个很好的计划。您需要在`thread_schedule`中添加对`thread_switch`的调用；您可以将需要的任何参数传递给`thread_switch`，但目的是将线程从`t`切换到`next_thread`。

* `thread_switch`只需要保存/还原被调用方保存的寄存器（callee-save register，参见LEC5使用的文档《Calling Convention》）调用者已经在自己的栈上保存了这些寄存器，当函数返回时，这些寄存器会自动恢复。

* 您可以在`user/uthread.asm`中看到`uthread`的汇编代码，这对于调试可能很方便。

* 这可能对于测试你的代码很有用，使用`riscv64-linux-gnu-gdb`的单步调试通过你的`thread_switch`，你可以按这种方法开始：

    ````bash
    (gdb) file user/_uthread
    Reading symbols from user/_uthread...
    (gdb) b uthread.c:60
    ````


## 二. Using threads ([moderate](https://pdos.csail.mit.edu/6.828/2020/labs/guidance.html))

### 1. 实验要求

在本作业中，您将探索使用哈希表的线程和锁的并行编程。您应该在具有多个内核的真实Linux或MacOS计算机（不是xv6，不是qemu）上执行此任务。最新的笔记本电脑都有多核处理器。这个作业使用UNIX的pthread线程库。您可以使用man pthreads在手册页面上找到关于它的信息。

### 2. 实验步骤

#### 2.1. 预处理

+ 构建一个包含不安全线程的哈希表的`ph`程序

    ````bash
    $ make ph
    gcc -o ph -g -O2 notxv6/ph.c -pthread
    ````


+ 运行`./ph 1`，即使用单线程运行该哈希表。输出表示没有键丢失

    ```
    $ ./ph 1
    100000 puts, 5.502 seconds, 18174 puts/second
    0: 0 keys missing
    100000 gets, 5.479 seconds, 18253 gets/second
    ```

+ 运行 `./ph 2` ，使用两个线程运行该哈希表。 put 速度大大加快，但是丢失了大量键

    ```
    $ ./ph 2
    100000 puts, 2.684 seconds, 37263 puts/second
    1: 16457 keys missing
    0: 16457 keys missing
    200000 gets, 6.601 seconds, 30298 gets/second
    ```

#### 2.2. 编写代码及配置

+ 定义互斥锁数组

    参考guidance，利用互斥锁来解决线程不安全的问题。对哈希表的处理，只有对同一个桶的操作才可能造成数据丢失，不同的桶之间是独立的互不影响的，所以这里需要的是一套互斥锁，每个桶都需要一个互斥锁。

    在`notxv6/ph.c`中进行定义

    ```
    pthread_mutex_t locks[NBUCKET]; // 互斥锁数组
    ```

+ 在`notxv6/ph.c`的`main（）`函数中，初始化所有的互斥锁

    ```
    int
    main(int argc, char *argv[])
    {
      pthread_t *tha;
      void *value;
      double t1, t0;
    
      if (argc < 2) {
        fprintf(stderr, "Usage: %s nthreads\n", argv[0]);
        exit(-1);
      }
      nthread = atoi(argv[1]);
      tha = malloc(sizeof(pthread_t) * nthread);
      srandom(0);
      assert(NKEYS % nthread == 0);
      for (int i = 0; i < NKEYS; i++) {
        keys[i] = random();
      }
      // 初始化互斥锁
      for(int i = 0; i < NBUCKET; ++i) {
          pthread_mutex_init(&locks[i], NULL);
      }
    
      //
      // first the puts
      // ...
    }
    
    ```

+ `put（）`函数加锁

    线程的安全问题是对桶中的链表进行操作而导致的，需要在链表操作的前后加锁，在`put`函数读写bucket之前加锁，在函数结束时释放锁,加锁的范围可以缩小到 `insert()` 函数。注意不要给 `get()` 加锁，它主要负责遍历桶的链表而寻找对应的入口，不会对链表做修改，只读操作，不需要修改。

    ```
    static 
    void put(int key, int value)
    {
      int i = key % NBUCKET;
    
    
      struct entry *e = 0;
      for (e = table[i]; e != 0; e = e->next) {
        if (e->key == key)
          break;
      }
      if(e){
        // 更新现有的key
        e->value = value;
      } else {
        pthread_mutex_lock(&locks[i]);    // 加锁
        insert(key, value, &table[i], table[i]);
        pthread_mutex_unlock(&locks[i]);  // 解锁
      }
    }
    
    ```

+ 修改 `NBUCKET` 

    原先双线程运行会有并发问题，是因为 `b%NBUCKET==0`, 使得两个同时运行的线程在执行`put(keys[b*n+i],n)`时, 实际上都是在操作 `i%NBUCKET` 这个桶,那么就很可能同时修改这个桶的链表头，非常容易发生丢失。但是加锁后会有同时抢夺锁和并发性能降低的问题。

    原来`NBUCKET`是5，这里修改了 `NBUCKET=7` ，散列效果会更好，使得 `b%NBUCKET!=0`, 那么两个同时运行的线程进行 `put()` 时便大概率不会对同一个 桶进行操作。

    ```
    #define NBUCKET 7   // lab7
    ```

#### 2.3. 程序测试

再次输入`./ph 2`进行测试

```
$ ./ph 2
100000 puts, 2.515 seconds, 39757 puts/second
1: 0 keys missing
0: 0 keys missing
200000 gets, 4.868 seconds, 41086 gets/second
```

进行单元测试`ph_fast`

```
./grade-lab-thread ph_fast
```

结果如下

```
make: 'kernel/kernel' is up to date.
== Test ph_fast == make: 'ph' is up to date.
ph_fast: OK (20.4s)
```

进行单元测试`ph_safe`

```
./grade-lab-thread ph_safe
```

结果如下

```
make: 'kernel/kernel' is up to date.
== Test ph_safe == make: 'ph' is up to date.
ph_safe: OK (8.1s)
```

### 3. 注意事项和提示

文件notxv6/ph.c包含一个简单的哈希表，如果单个线程使用，该哈希表是正确的，但是多个线程使用时，该哈希表是不正确的。在您的xv6主目录（可能是`~/xv6-labs-2020`）中，输入以下内容：

````bash
$ make ph
$ ./ph 1
````

请注意，要构建`ph`，`Makefile`使用操作系统的`gcc`，而不是6.S081的工具。`ph`的参数指定在哈希表上执行`put`和`get`操作的线程数。运行一段时间后，`ph 1`将产生与以下类似的输出：

````bash
100000 puts, 3.991 seconds, 25056 puts/second
0: 0 keys missing
100000 gets, 3.981 seconds, 25118 gets/second
````

您看到的数字可能与此示例输出的数字相差两倍或更多，这取决于您计算机的速度、是否有多个核心以及是否正在忙于做其他事情。

`ph`运行两个基准程序。首先，它通过调用`put()`将许多键添加到哈希表中，并以每秒为单位打印`puts`的接收速率。之后它使用get()从哈希表中获取键。它打印由于`puts`而应该在哈希表中但丢失的键的数量（在本例中为0），并以每秒为单位打印`gets`的接收数量。

通过给`ph`一个大于1的参数，可以告诉它同时从多个线程使用其哈希表。试试`ph 2`：

````bash
$ ./ph 2
100000 puts, 1.885 seconds, 53044 puts/second
1: 16579 keys missing
0: 16579 keys missing
200000 gets, 4.322 seconds, 46274 gets/second
````

这个`ph 2`输出的第一行表明，当两个线程同时向哈希表添加条目时，它们达到每秒53044次插入的总速率。这大约是运行`ph 1`的单线程速度的两倍。这是一个优秀的“并行加速”，大约达到了人们希望的2倍（即两倍数量的核心每单位时间产出两倍的工作）。

然而，声明`16579 keys missing`的两行表示散列表中本应存在的大量键不存在。也就是说，`puts`应该将这些键添加到哈希表中，但出现了一些问题。请看一下`notxv6/ph.c`，特别是`put()`和`insert()`。

为什么两个线程都丢失了键，而不是一个线程？确定可能导致键丢失的具有2个线程的事件序列。在answers-thread.txt中提交您的**序列**和**简短解释**。

为了避免这种事件序列，请在`notxv6/ph.c`中的`put`和`get`中插入`lock`和`unlock`语句，以便在两个线程中丢失的键数始终为0。相关的`pthread`调用包括：

````C
pthread_mutex_t lock; // declare a lock
pthread_mutex_init(&lock, NULL); // initialize the lock
pthread_mutex_lock(&lock); // acquire lock
pthread_mutex_unlock(&lock); // release lock
````

当`make grade`说您的代码通过`ph_safe`测试时，您就完成了，该测试需要两个线程的键缺失数为0。在此时，`ph_fast`测试失败是正常的。
不要忘记调用`pthread_mutex_init（）`

首先使用1个线程测试您的代码，然后使用2个线程测试它。 是否正确（即您是否消除了丢失的钥匙）？ 

相较于单线程版本，双线程版本是否可以实现并行加速（即，单位时间内更多的总工作量）？

在某些情况下，并发`put（）`在哈希表中读取或写入的内存中没有重叠， 因此不需要锁来保护彼此。 您可以更改`ph.c`来利用这种情况以获得某些`put（）`的并行加速吗？

 每个哈希存储桶有锁吗？修改您的代码，以便在保持正确性的同时并行运行某些`put`操作。 

当`make grade`表示您的代码通过`ph_safe`和`ph_fast`测试时，您就完成了。 `ph_fast`测试要求两个线程的每秒推入次数至少是一个线程的1.25倍。

## 三. Barrier([moderate](https://pdos.csail.mit.edu/6.828/2020/labs/guidance.html))

### 1. 实验要求

在本作业中，您将实现一个屏障`Barrier`：应用程序中的一个点，所有参与的线程在此点上必须等待，直到所有其他参与线程也达到该点。您将使用`pthread`条件变量，这是一种序列协调技术，类似于xv6的`sleep`和`wakeup`。

### 2. 实验步骤

#### 2.1. 预处理

+ 构建`barrier`程序，该程序要求多线程同时执行到同一位置后再继续运行

    ```
    $ make barrier
    gcc -o barrier -g -O2 notxv6/barrier.c -pthread
    ```

+ 运行 `./barrier 2` ，使用2个线程运行该程序，程序报错，运行失败。

    ```
    $ ./barrier 2
    barrier: notxv6/barrier.c:45: thread: Assertion `i == t' failed.
    barrier: notxv6/barrier.c:45: thread: Assertion `i == t' failed.
    Aborted (core dumped)
    ```

#### 2.2. 编写代码及配置

实现`barrier`函数，完成所需的屏障功能。它首先会加锁然后判断到达屏障点的线程数，如果所有线程都到达了就调用`pthread_cond_broadcast`唤醒其他线程，否则就调用`pthread_cond_wait`进行等待。

```
static void 
barrier()
{
  //new code

    
  pthread_mutex_lock(&bstate.barrier_mutex);
  //需要所有线程都调用barrier
  if(++bstate.nthread != nthread)  {    
    pthread_cond_wait(&bstate.barrier_cond,&bstate.barrier_mutex);  //等待
  } else {  // 所有线程到达barrier
    bstate.nthread = 0; // 重置nthread
    ++bstate.round; // round轮数增加
    pthread_cond_broadcast(&bstate.barrier_cond);   // 唤醒所有的睡眠线程
  }
  pthread_mutex_unlock(&bstate.barrier_mutex);
}

```

#### 2.3. 程序测试

依次输入指令`./barrier 1`，`./barrier 2`，`./barrier 5`进行测试

```
hane7ad@DESKTOP-O1CAKP8:~/xv6-labs-2020-lab7$ ./barrier 1
OK; passed
hane7ad@DESKTOP-O1CAKP8:~/xv6-labs-2020-lab7$ ./barrier 2
OK; passed
hane7ad@DESKTOP-O1CAKP8:~/xv6-labs-2020-lab7$ ./barrier 5
OK; passed
```

进行单元测试

```
./grade-lab-thread barrier
```

结果如下：

```
make: 'kernel/kernel' is up to date.
== Test barrier == make: 'barrier' is up to date.
barrier: OK (11.1s)
```

### 3. 注意事项和提示

您应该在真正的计算机（不是xv6，不是qemu）上完成此任务。

文件`notxv6/barrier.c`包含一个残缺的屏障实现。

````bash
$ make barrier
$ ./barrier 2
barrier: notxv6/barrier.c:42: thread: Assertion `i == t' failed.
````

指定在屏障上同步的线程数（`barrier.c`中的`nthread`）。每个线程执行一个循环。在每次循环迭代中，线程都会调用`barrier()`，然后以随机微秒数休眠。如果一个线程在另一个线程到达屏障之前离开屏障将触发断言（`assert`）。期望的行为是每个线程在`barrier()`中阻塞，直到`nthreads`的所有线程都调用了`barrier()`。

您的目标是实现期望的屏障行为。除了在`ph`作业中看到的`lock`原语外，还需要以下新的`pthread`原语:

````C
// 在cond上进入睡眠，释放锁mutex，在醒来时重新获取
pthread_cond_wait(&cond, &mutex);
// 唤醒睡在cond的所有线程
pthread_cond_broadcast(&cond);
````

确保您的方案通过`make grade`的`barrier`测试。

`pthread_cond_wait`在调用时释放`mutex`，并在返回前重新获取`mutex`。

我们已经为您提供了`barrier_init()`。您的工作是实现`barrier()`，这样`panic`就不会发生。我们为您定义了`struct barrier`；它的字段供您使用。
**有两个问题使您的任务变得复杂：**

你必须处理一系列的`barrier`调用，我们称每一连串的调用为一轮`round`。`bstate.round`记录当前轮数。每次当所有线程都到达屏障时，都应增加`bstate.round`。
您必须处理这样的情况：一个线程在其他线程退出`barrier`之前进入了下一轮循环。特别是，您在前后两轮中重复使用`bstate.nthread`变量。确保在前一轮仍在使用`bstate.nthread`时，离开`barrier`并循环运行的线程不会增加`bstate.nthread`。
使用一个、两个和两个以上的线程测试代码。

## 四. 总实验结果

在目录下创建`time.txt`，并输入完成实验的小时数。在终端执行

```
 ./grade-lab-thread
```

来对实验结果进行完全测试。

测试结果如下：

```
make: 'kernel/kernel' is up to date.
== Test uthread == uthread: OK (1.3s)
== Test answers-thread.txt == answers-thread.txt: OK
== Test ph_safe == make: 'ph' is up to date.
ph_safe: OK (7.8s)
== Test ph_fast == make: 'ph' is up to date.
ph_fast: OK (22.2s)
== Test barrier == make: 'barrier' is up to date.
barrier: OK (11.1s)
== Test time ==
time: OK
Score: 60/60
```

## 五. 遇到的问题及解决方法

有2个或多个线程时为什么造成数据丢失？

现在有两个线程T1和T2，他们都走到`put`函数，且假设两个线程中`key%NBUCKET`，即要插入同一个散列桶中。两个线程同时调用`insert(key, value, &table[i], table[i])`，insert是通过头插法实现的。如果首先调用`insert`的线程还执行结束时另一个线程就开始执行`insert`，那么前者的数据会被覆盖。



# Lab8. Locks

## 一. Memory allocator ([moderate](https://pdos.csail.mit.edu/6.828/2020/labs/guidance.html))

### 1. 实验要求

您的工作是实现每个CPU的空闲列表，并在CPU的空闲列表为空时进行窃取。 您必须提供所有以`kmem`开头的锁名称。 也就是说，您应该为每个锁调用`initlock`，并传递以` kmem`开头的名称。 运行`kalloctest`以查看您的实现是否减少了锁争用。 要检查它是否仍可以分配所有内存，请运行`usertests sbrkmuch`。 您的输出将类似于以下所示，尽管`kmem`锁的总争用数量有所减少，但总争用减少了很多。 确保`usertests`中的所有测试均通过。` make grade`应该说`kalloctests`通过了。

```
$ kalloctest
start test1
test1 results:
--- lock kmem/bcache stats
lock: kmem: #fetch-and-add 0 #acquire() 42843
lock: kmem: #fetch-and-add 0 #acquire() 198674
lock: kmem: #fetch-and-add 0 #acquire() 191534
lock: bcache: #fetch-and-add 0 #acquire() 1242
--- top 5 contended locks:
lock: proc: #fetch-and-add 43861 #acquire() 117281
lock: virtio_disk: #fetch-and-add 5347 #acquire() 114
lock: proc: #fetch-and-add 4856 #acquire() 117312
lock: proc: #fetch-and-add 4168 #acquire() 117316
lock: proc: #fetch-and-add 2797 #acquire() 117266
tot= 0
test1 OK
start test2
total free number of pages: 32499 (out of 32768)
.....
test2 OK
$ usertests sbrkmuch
usertests starting
test sbrkmuch: OK
ALL TESTS PASSED
$ usertests
...
ALL TESTS PASSED
$
```

### 2. 实验步骤

#### 2.1. 编写代码及配置

**本实验的代码修改均在`kernel/kalloc.c`中进行**

+ 使用`kernel/param.h`中的常量`NCPU`修改`kmem`的结构体定义，为多核的每个CPU都分配一份结构体。

    ```
    struct {
      struct spinlock lock;
      struct run *freelist;
    } kmem[NCPU];   //修改为数组
    ```

+ 修改`kinit`函数，为当前CPU的`freelist`分配所有的空闲内存空间

    ```
    void
    kinit()
    {
      for (int i = 0; i < NCPU; i++)
        initlock(&kmem[i].lock, "kmem");
      freerange(end, (void*)PHYSTOP);
    }
    ```

+ 修改`kfree`函数，注意要先关闭中断再获取CPU的id，然后对一个具体的CPU进行操作。

    ```
    void
    kfree(void *pa)
    {
      //...
      //获取cpuid
      //lab 8-1 add
      push_off();
      int id = cpuid();
      pop_off();
    
      acquire(&kmem[id].lock);
      r->next = kmem[id].freelist;
      kmem[id].freelist = r;
      release(&kmem[id].lock);
    }
    ```

+ 修改`kalloc`函数，查找判断当前CPU是否有空闲的内存块，若有则直接返回；若无，则从其他CPU中获取一块空闲内存。

    ```
    void *
    kalloc(void)
    {
      struct run *r;
    
      //关闭中断再获取cpuid
      push_off();
      int id = cpuid();
      pop_off();
    
      acquire(&kmem[id].lock);
      r = kmem[id].freelist;
       //有空闲内存块
      if(r)
        kmem[id].freelist = r->next;
      else {//无空闲内存块
        for (int i = 0; i < NCPU; i++) {
          if (i == id) 
              continue;
          acquire(&kmem[i].lock);
          r = kmem[i].freelist;
          if(r)
            kmem[i].freelist = r->next;
          release(&kmem[i].lock);
          if(r) 
              break;
        }
      }
      release(&kmem[id].lock);
    
      if(r)
        memset((char*)r, 5, PGSIZE); // fill with junk
      return (void*)r;
    }
    ```

#### 2.2. 程序测试

启动xv6,输入指令`kalloctest`进行测试

```
$ kalloctest
start test1
test1 results:
--- lock kmem/bcache stats
lock: kmem: #fetch-and-add 0 #acquire() 91146
lock: kmem: #fetch-and-add 0 #acquire() 166580
lock: kmem: #fetch-and-add 0 #acquire() 175324
lock: bcache: #fetch-and-add 0 #acquire() 1248
--- top 5 contended locks:
lock: proc: #fetch-and-add 37637 #acquire() 122404
lock: virtio_disk: #fetch-and-add 26174 #acquire() 114
lock: proc: #fetch-and-add 6701 #acquire() 122428
lock: proc: #fetch-and-add 5099 #acquire() 122459
lock: proc: #fetch-and-add 5096 #acquire() 122455
tot= 0
test1 OK
start test2
total free number of pages: 32499 (out of 32768)
.....
test2 OK
$
```

输入指令`usertests sbrkmuch`进行测试

```
$ usertests sbrkmuch
usertests starting
test sbrkmuch: OK
ALL TESTS PASSED
$
```

### 3. 注意事项和提示

* 您可以使用`kernel / param.h`中的常量`NCPU`。让`freerange`将所有可用内存分配给运行`freerange`的CPU。
* `cpuid`函数返回当前内核号，但是只有在中断关闭时调用它并使用其结果才是安全的。 您应该使用`push_off（）`和`pop_off（）`来打开和关闭中断。
* 查看`kernel / sprintf.c`中的`snprintf`函数以了解字符串格式设置的思想。 可以只将所有锁命名为` kmem`。

## 二. Buffer cache ([hard](https://pdos.csail.mit.edu/6.828/2020/labs/guidance.html))

### 1. 实验要求

如果多个进程密集使用文件系统，则它们可能会争用`bcache.lock`，这可以保护`kernel / bio.c`中的磁盘块缓存。 `bcachetest`创建多个进程，这些进程重复读取不同的文件，以便在`bcache.lock`上产生争用； 其输出如下所示（在完成本实验之前）：

```text
$ bcachetest
start test0
test0 results:
--- lock kmem/bcache stats
lock: kmem: #fetch-and-add 0 #acquire() 33035
lock: bcache: #fetch-and-add 16142 #acquire() 65978
--- top 5 contended locks:
lock: virtio_disk: #fetch-and-add 162870 #acquire() 1188
lock: proc: #fetch-and-add 51936 #acquire() 73732
lock: bcache: #fetch-and-add 16142 #acquire() 65978
lock: uart: #fetch-and-add 7505 #acquire() 117
lock: proc: #fetch-and-add 6937 #acquire() 73420
tot= 16142
test0: FAIL
start test1
test1 OK
```

您可能会看到不同的输出，但是`bcache`锁的获取循环迭代次数将很高。 如果查看`kernel / bio.c`中的代码，您将看到`bcache.lock`保护了缓存的块缓冲区列表，每个块缓冲区中的引用计数（`b-> refcnt`）以及缓存的块的标识 （`b-> dev`和`b-> blockno`）。

**修改块缓存，以便在运行`bcachetest`时，`bcache`中所有锁的获取循环迭代次数接近于零。目的是通过重新设计文件系统的 buffer & cache 的数据结构来降低锁的竞争**

 理想情况下，块高速缓存中涉及的所有锁的计数总和应为零，但如果总和小于500则可以。修改`bget`和`brelse`，以使并发查找和释放`bcache`中不同块的可能性不大。 锁冲突（例如，不必全部等待`bcache.lock`）。 您必须保持不变，即每个块最多缓存一个副本。 完成后，您的输出应类似于以下所示（尽管不完全相同）。 确保用户测试仍然通过。 完成后，等级应通过所有测试。

````bash
$ bcachetest
start test0
test0 results:
--- lock kmem/bcache stats
lock: kmem: #fetch-and-add 0 #acquire() 32954
lock: kmem: #fetch-and-add 0 #acquire() 75
lock: kmem: #fetch-and-add 0 #acquire() 73
lock: bcache: #fetch-and-add 0 #acquire() 85
lock: bcache.bucket: #fetch-and-add 0 #acquire() 4159
lock: bcache.bucket: #fetch-and-add 0 #acquire() 2118
lock: bcache.bucket: #fetch-and-add 0 #acquire() 4274
lock: bcache.bucket: #fetch-and-add 0 #acquire() 4326
lock: bcache.bucket: #fetch-and-add 0 #acquire() 6334
lock: bcache.bucket: #fetch-and-add 0 #acquire() 6321
lock: bcache.bucket: #fetch-and-add 0 #acquire() 6704
lock: bcache.bucket: #fetch-and-add 0 #acquire() 6696
lock: bcache.bucket: #fetch-and-add 0 #acquire() 7757
lock: bcache.bucket: #fetch-and-add 0 #acquire() 6199
lock: bcache.bucket: #fetch-and-add 0 #acquire() 4136
lock: bcache.bucket: #fetch-and-add 0 #acquire() 4136
lock: bcache.bucket: #fetch-and-add 0 #acquire() 2123
--- top 5 contended locks:
lock: virtio_disk: #fetch-and-add 158235 #acquire() 1193
lock: proc: #fetch-and-add 117563 #acquire() 3708493
lock: proc: #fetch-and-add 65921 #acquire() 3710254
lock: proc: #fetch-and-add 44090 #acquire() 3708607
lock: proc: #fetch-and-add 43252 #acquire() 3708521
tot= 128
test0: OK
start test1
test1 OK
$ usertests
  ...
ALL TESTS PASSED
$
````

请提供所有以“` bcache`”开头的锁名称。 也就是说，您应该为每个锁调用`initlock`，并传递以“ `bcache`”开头的名称。

### 2. 实验步骤

#### 2.1. 编写代码及配置

+ 按照提示，将`NBUCKET`改为质数13，将`buffer`分为13个桶

    ```
    //param.h
    #define NBUCKET      13  // size of disk block cache
    ```

+ 修改`bcache`结构体，将`lock`和`head`改为数组，表示`buffer`中的每一个桶都有`lock`和`head`

    ```
    struct {
      struct spinlock biglock;
      struct spinlock lock[NBUCKET];  //lock of each bucket; lab 8-2 add
      struct buf buf[NBUF];
    
      // Linked list of all buffers, through prev/next.
      // Sorted by how recently the buffer was used.
      // head.next is most recent, head.prev is least.
      struct buf head[NBUCKET]; // lab 8-2 modified
    } bcache;
    ```

+ 在` kernel/buf.h`中添加`lastuse`字段

    ```
    struct buf {
      int valid;   // has data been read from disk?
      int disk;    // does disk "own" buf?
      uint dev;
      uint blockno;
      struct sleeplock lock;
      uint refcnt;
      struct buf *prev; // LRU cache list
      struct buf *next;
      uchar data[BSIZE];
      uint lastuse;
    };
    ```

+ 修改`kernel/bio.c`的`binit`函数，完成链表的初始化。首先初始化散列桶的锁，然后将所有散列桶的前驱指针和后驱指针都指向自身表示为空，并将所有的缓冲区挂载到`bucket[0]`桶上。

    ```
    //kernel/bio.c
    void
    binit(void)
    {
      struct buf *b;
    
      initlock(&bcache.biglock, "bcache_biglock");
      for (int i = 0; i < NBUCKET; i++)
        initlock(&bcache.lock[i], "bcache");
    
      // Create linked list of buffers
      //bcache.head.prev = &bcache.head;
      //bcache.head.next = &bcache.head;
      //每个节点前驱后继都是自身，初始化  
      for (int i = 0; i < NBUCKET; i++) {
        bcache.head[i].next = &bcache.head[i];
        bcache.head[i].prev = &bcache.head[i];
      }
        
      for(b = bcache.buf; b < bcache.buf+NBUF; b++){
        b->next = bcache.head[0].next;
        b->prev = &bcache.head[0];
        initsleeplock(&b->lock, "buffer");
        bcache.head[0].next->prev = b;
        bcache.head[0].next = b;
      }
    }
    ```

+ 添加一个散列函数`hash`，通过取模进行散列，方便后续将缓冲区对应到相应的桶中。并在`bunpin`和`bpin`函数中调用`hash`函数

    ```
    // kernel/bio.c
    // hash function; lab 8-2 add
    int
    hash(int blockno)
    {
      return blockno % NBUCKET;
    }
    void
    bpin(struct buf *b) {
      int i = hash(b->blockno);
      acquire(&bcache.lock[i]);
      b->refcnt++;
      release(&bcache.lock[i]);
    }
    
    void
    bunpin(struct buf *b) {
      int i = hash(b->blockno);
      acquire(&bcache.lock[i]);
      b->refcnt--;
      release(&bcache.lock[i]);
    }
    ```

+ 修改`brelse`函数，使`brelse`不需要获取`bcache`锁

    ```
    void
    brelse(struct buf *b)
    {
      if(!holdingsleep(&b->lock))
        panic("brelse");
    
      releasesleep(&b->lock);
    
      //lab 8-2 modified
      int i = hash(b->blockno);
      acquire(&bcache.lock[i]);
      b->refcnt--;
      if (b->refcnt == 0) {
        // no one is waiting for it.
        /*b->next->prev = b->prev;
        b->prev->next = b->next;
        b->next = bcache.head.next;
        b->prev = &bcache.head;
        bcache.head.next->prev = b;
        bcache.head.next = b;*/
        b->lastuse = ticks;
      }
      release(&bcache.lock[i]);
    }
    ```

+ 修改`bget`。

    首先需要遍历判断缓存是否命中，若命中了，可以直接返回；

    若未命中，先要按从大到小的顺序释放锁，释放锁之后，可能会有心的缓存，需要再次遍历判断是否命中；

    若仍然未命中，就查找当前这个桶所属的LRU空闲块，按`ticks`的方式查找，获取空闲块；

    若无，就只能去其他桶中获取空闲块。

    ```
    //kernel/bio.c
    static struct buf*
    bget(uint dev, uint blockno)
    {
      struct buf *b, *b2 = 0;
    
      int i = hash(blockno), min_ticks = 0;
      acquire(&bcache.lock[i]);
    
      // 首先判断是否命中
      for(b = bcache.head[i].next; b != &bcache.head[i]; b = b->next){
        //若命中了，直接返回
        if(b->dev == dev && b->blockno == blockno){
          b->refcnt++;
          release(&bcache.lock[i]);
          acquiresleep(&b->lock);
          return b;
        }
      }
      release(&bcache.lock[i]);
    
        
      acquire(&bcache.biglock);
      acquire(&bcache.lock[i]);
      // 在当前桶中查找空闲块
      for (b = bcache.head[i].next; b != &bcache.head[i]; b = b->next) {
        if(b->dev == dev && b->blockno == blockno) {
          b->refcnt++;
          release(&bcache.lock[i]);
          release(&bcache.biglock);
          acquiresleep(&b->lock);
          return b;
        }
      }
     
      for (b = bcache.head[i].next; b != &bcache.head[i]; b = b->next) {
        if (b->refcnt == 0 && (b2 == 0 || b->lastuse < min_ticks)) {
          min_ticks = b->lastuse;
          b2 = b;
        }
      }
      if (b2) {
        b2->dev = dev;
        b2->blockno = blockno;
        b2->refcnt++;
        b2->valid = 0;
        //acquiresleep(&b2->lock);
        release(&bcache.lock[i]);
        release(&bcache.biglock);
        acquiresleep(&b2->lock);
        return b2;
      }
      // 从其他桶中查找空闲块
      for (int j = hash(i + 1); j != i; j = hash(j + 1)) {
        acquire(&bcache.lock[j]);
        for (b = bcache.head[j].next; b != &bcache.head[j]; b = b->next) {
          if (b->refcnt == 0 && (b2 == 0 || b->lastuse < min_ticks)) {
            min_ticks = b->lastuse;
            b2 = b;
          }
        }
        if(b2) {
          b2->dev = dev;
          b2->refcnt++;
          b2->valid = 0;
          b2->blockno = blockno;
          // 从原桶中删除
          b2->next->prev = b2->prev;
          b2->prev->next = b2->next;
          release(&bcache.lock[j]);
          //加锁
          b2->next = bcache.head[i].next;
          b2->prev = &bcache.head[i];
          bcache.head[i].next->prev = b2;
          bcache.head[i].next = b2;
          release(&bcache.lock[i]);
          release(&bcache.biglock);
          acquiresleep(&b2->lock);
          return b2;
        }
        release(&bcache.lock[j]);
      }
      release(&bcache.lock[i]);
      release(&bcache.biglock);
      panic("bget: no buffers");
    
    ```

#### 2.2. 程序测试

启动xv6,输入指令`bcachetest`进行测试

```
$ bcachetest
start test0
test0 results:
--- lock kmem/bcache stats
lock: kmem: #fetch-and-add 0 #acquire() 32962
lock: kmem: #fetch-and-add 0 #acquire() 82
lock: kmem: #fetch-and-add 0 #acquire() 38
lock: bcache_biglock: #fetch-and-add 0 #acquire() 118
lock: bcache: #fetch-and-add 0 #acquire() 2128
lock: bcache: #fetch-and-add 0 #acquire() 4123
lock: bcache: #fetch-and-add 0 #acquire() 4333
lock: bcache: #fetch-and-add 0 #acquire() 6343
lock: bcache: #fetch-and-add 0 #acquire() 6340
lock: bcache: #fetch-and-add 0 #acquire() 6331
lock: bcache: #fetch-and-add 0 #acquire() 6615
lock: bcache: #fetch-and-add 0 #acquire() 6639
lock: bcache: #fetch-and-add 0 #acquire() 6949
lock: bcache: #fetch-and-add 0 #acquire() 4137
lock: bcache: #fetch-and-add 0 #acquire() 4138
lock: bcache: #fetch-and-add 0 #acquire() 2127
lock: bcache: #fetch-and-add 0 #acquire() 4136
--- top 5 contended locks:
lock: virtio_disk: #fetch-and-add 213478 #acquire() 1202
lock: proc: #fetch-and-add 51530 #acquire() 72598
lock: proc: #fetch-and-add 13550 #acquire() 72254
lock: proc: #fetch-and-add 5820 #acquire() 72260
lock: proc: #fetch-and-add 5145 #acquire() 72265
tot= 0
test0: OK
start test1
test1 OK
$
```

输入指令`usertests`进行测试

```
$ usertests
usertests starting
test manywrites: OK
test execout: OK
test copyin: OK
test copyout: OK
test copyinstr1: OK
test copyinstr2: OK
test copyinstr3: OK
test rwsbrk: OK
test truncate1: OK
test truncate2: OK
test truncate3: OK
test reparent2: OK
test pgbug: OK
test sbrkbugs: usertrap(): unexpected scause 0x000000000000000c pid=3246
            sepc=0x00000000000056a4 stval=0x00000000000056a4
usertrap(): unexpected scause 0x000000000000000c pid=3247
            sepc=0x00000000000056a4 stval=0x00000000000056a4
OK
test badarg: OK
test reparent: OK
test twochildren: OK
test forkfork: OK
test forkforkfork: OK
test argptest: OK
test createdelete: OK
test linkunlink: OK
test linktest: OK
test unlinkread: OK
test concreate: OK
test subdir: OK
test fourfiles: OK
test sharedfd: OK
test dirtest: OK
test exectest: OK
test bigargtest: OK
test bigwrite: OK
test bsstest: OK
test sbrkbasic: OK
test sbrkmuch: OK
test kernmem: usertrap(): unexpected scause 0x000000000000000d pid=6227
            sepc=0x000000000000215c stval=0x0000000080000000
usertrap(): unexpected scause 0x000000000000000d pid=6228
            sepc=0x000000000000215c stval=0x000000008000c350
usertrap(): unexpected scause 0x000000000000000d pid=6229
            sepc=0x000000000000215c stval=0x00000000800186a0
usertrap(): unexpected scause 0x000000000000000d pid=6230
            sepc=0x000000000000215c stval=0x00000000800249f0
usertrap(): unexpected scause 0x000000000000000d pid=6231
            sepc=0x000000000000215c stval=0x0000000080030d40
usertrap(): unexpected scause 0x000000000000000d pid=6232
            sepc=0x000000000000215c stval=0x000000008003d090
usertrap(): unexpected scause 0x000000000000000d pid=6233
            sepc=0x000000000000215c stval=0x00000000800493e0
usertrap(): unexpected scause 0x000000000000000d pid=6234
            sepc=0x000000000000215c stval=0x0000000080055730
usertrap(): unexpected scause 0x000000000000000d pid=6235
            sepc=0x000000000000215c stval=0x0000000080061a80
usertrap(): unexpected scause 0x000000000000000d pid=6236
            sepc=0x000000000000215c stval=0x000000008006ddd0
usertrap(): unexpected scause 0x000000000000000d pid=6237
            sepc=0x000000000000215c stval=0x000000008007a120
usertrap(): unexpected scause 0x000000000000000d pid=6238
            sepc=0x000000000000215c stval=0x0000000080086470
usertrap(): unexpected scause 0x000000000000000d pid=6239
            sepc=0x000000000000215c stval=0x00000000800927c0
usertrap(): unexpected scause 0x000000000000000d pid=6240
            sepc=0x000000000000215c stval=0x000000008009eb10
usertrap(): unexpected scause 0x000000000000000d pid=6241
            sepc=0x000000000000215c stval=0x00000000800aae60
usertrap(): unexpected scause 0x000000000000000d pid=6242
            sepc=0x000000000000215c stval=0x00000000800b71b0
usertrap(): unexpected scause 0x000000000000000d pid=6243
            sepc=0x000000000000215c stval=0x00000000800c3500
usertrap(): unexpected scause 0x000000000000000d pid=6244
            sepc=0x000000000000215c stval=0x00000000800cf850
usertrap(): unexpected scause 0x000000000000000d pid=6245
            sepc=0x000000000000215c stval=0x00000000800dbba0
usertrap(): unexpected scause 0x000000000000000d pid=6246
            sepc=0x000000000000215c stval=0x00000000800e7ef0
usertrap(): unexpected scause 0x000000000000000d pid=6247
            sepc=0x000000000000215c stval=0x00000000800f4240
usertrap(): unexpected scause 0x000000000000000d pid=6248
            sepc=0x000000000000215c stval=0x0000000080100590
usertrap(): unexpected scause 0x000000000000000d pid=6249
            sepc=0x000000000000215c stval=0x000000008010c8e0
usertrap(): unexpected scause 0x000000000000000d pid=6250
            sepc=0x000000000000215c stval=0x0000000080118c30
usertrap(): unexpected scause 0x000000000000000d pid=6251
            sepc=0x000000000000215c stval=0x0000000080124f80
usertrap(): unexpected scause 0x000000000000000d pid=6252
            sepc=0x000000000000215c stval=0x00000000801312d0
usertrap(): unexpected scause 0x000000000000000d pid=6253
            sepc=0x000000000000215c stval=0x000000008013d620
usertrap(): unexpected scause 0x000000000000000d pid=6254
            sepc=0x000000000000215c stval=0x0000000080149970
usertrap(): unexpected scause 0x000000000000000d pid=6255
            sepc=0x000000000000215c stval=0x0000000080155cc0
usertrap(): unexpected scause 0x000000000000000d pid=6256
            sepc=0x000000000000215c stval=0x0000000080162010
usertrap(): unexpected scause 0x000000000000000d pid=6257
            sepc=0x000000000000215c stval=0x000000008016e360
usertrap(): unexpected scause 0x000000000000000d pid=6258
            sepc=0x000000000000215c stval=0x000000008017a6b0
usertrap(): unexpected scause 0x000000000000000d pid=6259
            sepc=0x000000000000215c stval=0x0000000080186a00
usertrap(): unexpected scause 0x000000000000000d pid=6260
            sepc=0x000000000000215c stval=0x0000000080192d50
usertrap(): unexpected scause 0x000000000000000d pid=6261
            sepc=0x000000000000215c stval=0x000000008019f0a0
usertrap(): unexpected scause 0x000000000000000d pid=6262
            sepc=0x000000000000215c stval=0x00000000801ab3f0
usertrap(): unexpected scause 0x000000000000000d pid=6263
            sepc=0x000000000000215c stval=0x00000000801b7740
usertrap(): unexpected scause 0x000000000000000d pid=6264
            sepc=0x000000000000215c stval=0x00000000801c3a90
usertrap(): unexpected scause 0x000000000000000d pid=6265
            sepc=0x000000000000215c stval=0x00000000801cfde0
usertrap(): unexpected scause 0x000000000000000d pid=6266
            sepc=0x000000000000215c stval=0x00000000801dc130
OK
test sbrkfail: usertrap(): unexpected scause 0x000000000000000d pid=6278
            sepc=0x00000000000041fc stval=0x0000000000012000
OK
test sbrkarg: OK
test validatetest: OK
test stacktest: usertrap(): unexpected scause 0x000000000000000d pid=6282
            sepc=0x00000000000022cc stval=0x000000000000fb90
OK
test opentest: OK
test writetest: OK
test writebig: OK
test createtest: OK
test openiput: OK
test exitiput: OK
test iput: OK
test mem: OK
test pipe1: OK
test preempt: kill... wait... OK
test exitwait: OK
test rmdot: OK
test fourteen: OK
test bigfile: OK
test dirfile: OK
test iref: OK
test forktest: OK
test bigdir: OK
ALL TESTS PASSED
$
```

### 3. 注意事项和提示

与`balloc`相比，减少块缓存中的争用更为棘手，因为`bcache`缓冲区确实在进程之间（因此在CPU之间）共享--`kalloc`只需要分配内存而不存在数据共享，`kalloc`可以通过为每个CPU分配自己的分配器来消除大多数争用。 不适用于块缓存。 我们建议您使用一个哈希表在缓存中查找块号，该哈希表每个哈希存储桶均具有锁定状态。

在某些情况下，如果您的解决方案存在锁冲突，则可以：

* 当两个进程同时使用相同的块号时。 `bcachetest test0`从来没有这样做。

* 当两个进程同时在缓存中丢失时，需要找到一个未使用的块来替换。 `bcachetest test0`从来没有这样做。

* 当两个进程同时使用与您用来对块和锁进行分区的方案冲突的块时； 例如，如果两个进程使用其块号哈希到哈希表中同一插槽的块。 `bcachetest test0`可能会执行此操作，具体取决于您的设计，但您应尝试调整方案的详细信息以避免冲突（例如，更改哈希表的大小）。

* `bcachetest`的`test1`使用的缓冲区多于缓冲区，并且练习了许多文件系统代码路径。

这里有一些提示

* 阅读xv6书中有关块缓存的说明（第8.1-8.3节）。

* 可以使用固定数量的存储桶，而不动态调整哈希表的大小。 使用主要数量的存储桶（例如13个）来减少散列冲突的可能性。

* 在哈希表中搜索缓冲区，并在找不到缓冲区时为该缓冲区分配一个条目，这必须是原子的。

* 删除所有缓冲区的列表（`bcache.head`等），而是使用上次使用的时间（即，使用`kernel / trap.c`中的滴答声）来标记时间戳。 通过此更改，`brelse`不需要获取`bcache`锁，并且`bget`可以根据时间戳选择最近最少使用的块。

* 可以在`bget`中对逐出进行序列化（即，当在高速缓存中未找到查询时，`bget`会选择要重新使用的缓冲区的部分）。

* 在某些情况下，您的解决方案可能需要按住两个锁。 例如，在驱逐期间，您可能需要按住`bcache`锁和每个存储桶锁。 确保避免死锁。

* 更换块时，您可以将`struct buf`从一个存储桶移动到另一个存储桶，因为新的块散列到另一个存储桶。 您可能会遇到一个棘手的情况：新块可能会散列到与旧块相同的存储桶中。 确保在这种情况下避免死锁。

一些调试技巧：实现存储桶锁定，但在`bget`的开始/结尾保留全局`bcache.lock`获取/释放，以序列化代码。 一旦确定没有争用条件是正确的，请删除全局锁并处理并发问题。 您也可以运行`make CPUS = 1 qemu`来测试一个内核。

## 三. 总实验结果

在目录下创建`time.txt`，并输入完成实验的小时数。在终端执行

```
 ./grade-lab-lock
```

来对实验结果进行完全测试。

测试结果如下：

```
make: 'kernel/kernel' is up to date.
== Test running kalloctest == (73.5s)
== Test   kalloctest: test1 ==
  kalloctest: test1: OK
== Test   kalloctest: test2 ==
  kalloctest: test2: OK
== Test kalloctest: sbrkmuch == kalloctest: sbrkmuch: OK (8.7s)
== Test running bcachetest == (6.3s)
== Test   bcachetest: test0 ==
  bcachetest: test0: OK
== Test   bcachetest: test1 ==
  bcachetest: test1: OK
== Test usertests == usertests: OK (135.5s)
== Test time ==
time: OK
Score: 70/70
```

## 四. 遇到的问题及解决方法

有时候使用 `./make-grade-lock` 命令进行单元测试会报错，如 `panic:freeing free block` 错误。

解决方法：在测试之前先使用`make clean`进行清理。



# Lab9. file system

## 一. Large files ([moderate](https://pdos.csail.mit.edu/6.828/2020/labs/guidance.html))

### 1. 实验要求

在此作业中，您将增加xv6文件的最大大小。 当前，xv6文件限制为268个块或268 * BSIZE字节（xv6中`BSIZE`为1024）。 此限制来自以下事实：xv6索引节点包含12个“直接”块编号和一个“单间接”块编号，这是指最多容纳256个以上块编号的块，总共12 + 256 = 268 块。

bigfile命令会创建最长的文件，并报告该大小：

````bash
$ bigfile
..
wrote 268 blocks
bigfile: file is too small
$
````

测试失败，因为`bigfile`希望能够创建具有65803个块的文件，但是未经修改的xv6会将文件限制为268个块。

您将更改xv6文件系统代码，以在每个inode中支持“双重间接”块，其中包含256个单间接块地址，每个间接块最多可以包含256个数据块地址。 结果将是一个文件最多可以包含65803个块或256 * 256 + 256 + 11个块（11个代替12个，因为我们将为双间接块牺牲一个直接块号） 。

### 2. 实验步骤

#### 2.1. 编写代码及配置

+ 修改直接块数量

    实验要求为xv6的文件系统添加一个二级索引，由于总的索引个数仍然是13，需要牺牲1个直接索引,换成新的二级索引。即11个直接索引+1个一级索引+1个二级索引,总共索引11+256+256*256=65803个盘块。

    修改`kernel/fs.h`直接块号的宏定义 `NDIRECT` 为11

    ````c
    #define NDIRECT 11//直接块改为11个
    ````

    实际`inode`块号总数不变，但是`NDIRECT`减少了，需要修改`inode`相关结构体的块号数组。

    修改 `kernel/fs.h` 中的磁盘 inode 结构体 `struct dinode`的 `addrs` 字段;

    修改`kernel/file.h` 中的内存 inode 结构体 `struct inode` 的 `addrs` 字段。

    ````c
    // On-disk inode structure
    struct dinode {
      // ...
      uint addrs[NDIRECT+2];   // Data block addresses +1->+2
    };
    
    // in-memory copy of an inode
    struct inode {
      // ...
      uint addrs[NDIRECT+2];    // lab9-1  ,+1->+2
    };
    ````

+ 添加二级索引的宏定义

    类似于`NINDIRECT`表示的是一级索引块号的总数256，在 `kernel/fs.h` 中添加宏定义 `NDOUBLYINDIRECT`，它表示二级索引块号的总数,能够表示的块号个数是一级索引的平方256*256。

    ````c
    #define NDOUBLYINDIRECT (NINDIRECT * NINDIRECT)     // 二级索引块号总数
    ````

+ 修改`bmap（）`函数

    `bamp`函数的功能是用于返回` inode `的相对块号对应的磁盘中的块号。`bmap`会检查参数`bn`位于哪个区间，是哪种索引,如果是直接索引就直接访问，如果没有对应数据块的话就调用`balloc()`分配一个新的块。如果超出了`direct`的范围，,说明是一级索引，就把`bn`减去`NDIRECT`的偏移量，先访问`addrs[11]`指向的一级指针块，使用一级指针块里面的指针访问数据块。

    现在要添加二级索引的功能，仿照一级索引，再重复嵌套一次一级索引的操作即可。

    修改`kernel/fs.c`的`bmap（）`函数

    ```
    static uint
    bmap(struct inode *ip, uint bn)
    {
      uint addr, *a;
      struct buf *bp;
    
      if(bn < NDIRECT){
        if((addr = ip->addrs[bn]) == 0)
          ip->addrs[bn] = addr = balloc(ip->dev);
        return addr;
      }
      bn -= NDIRECT;
    
      if(bn < NINDIRECT){
        // Load indirect block, allocating if necessary.
        if((addr = ip->addrs[NDIRECT]) == 0)
          ip->addrs[NDIRECT] = addr = balloc(ip->dev);
        bp = bread(ip->dev, addr);
        a = (uint*)bp->data;
        if((addr = a[bn]) == 0){
          a[bn] = addr = balloc(ip->dev);
          log_write(bp);
        }
        brelse(bp);
        return addr;
      }
    
      // 二级索引
      bn -= NINDIRECT;
      if(bn < NDOUBLYINDIRECT) {
        // 获取锁
        if((addr = ip->addrs[NDIRECT + 1]) == 0) {
          ip->addrs[NDIRECT + 1] = addr = balloc(ip->dev);
        }
        bp = bread(ip->dev, addr);
        a = (uint*)bp->data;
        // 获取一级索引地址
        if((addr = a[bn / NINDIRECT]) == 0) {
          a[bn / NINDIRECT] = addr = balloc(ip->dev);
          log_write(bp);
        }
        brelse(bp);
        bp = bread(ip->dev, addr);
        a = (uint*)bp->data;
        bn %= NINDIRECT;
        // 获取直接索引地址
        if((addr = a[bn]) == 0) {
          a[bn] = addr = balloc(ip->dev);
          log_write(bp);
        }
        brelse(bp);
        return addr;
      }
    
      panic("bmap: out of range");
    }
    
    ```

+ 修改`itrunc`释放数据块

    该函数负责释放` inode` 所有的数据块，添加了二级索引的结构，对应的也需要释放二级索引的数据块。实现也较为简单，只需两层循环，依次遍历二级索引与内层的一级索引即可。

    修改`kernel/fs.c`的`itrunc（）`函数

    ````c
    void
    itrunc(struct inode *ip)
    {
      int i, j, k;  // 新增k用于循环
      struct buf *bp, *bp2;     //新增bp2
      uint *a, *a2; // 新增a2
    
      for(i = 0; i < NDIRECT; i++){
        if(ip->addrs[i]){
          bfree(ip->dev, ip->addrs[i]);
          ip->addrs[i] = 0;
        }
      }
    
      if(ip->addrs[NDIRECT]){
        bp = bread(ip->dev, ip->addrs[NDIRECT]);
        a = (uint*)bp->data;
        for(j = 0; j < NINDIRECT; j++){
          if(a[j])
            bfree(ip->dev, a[j]);
        }
        brelse(bp);
        bfree(ip->dev, ip->addrs[NDIRECT]);
        ip->addrs[NDIRECT] = 0;
      }
      // 释放二级索引的数据块
      if(ip->addrs[NDIRECT + 1]) {
        bp = bread(ip->dev, ip->addrs[NDIRECT + 1]);
        a = (uint*)bp->data;
        //遍历二级索引
        for(j = 0; j < NINDIRECT; ++j) {
          if(a[j]) {
            bp2 = bread(ip->dev, a[j]);
            a2 = (uint*)bp2->data;
              //内层遍历
            for(k = 0; k < NINDIRECT; ++k) {
              if(a2[k]) {
                bfree(ip->dev, a2[k]);
              }
            }
              //释放
            brelse(bp2);
            bfree(ip->dev, a[j]);
            a[j] = 0;
          }
        }
          //释放
        brelse(bp);
        bfree(ip->dev, ip->addrs[NDIRECT + 1]);
        ip->addrs[NDIRECT + 1] = 0;
      }
    
      ip->size = 0;
      iupdate(ip);
    }
    
    ````

    5.修改文件最大体积的宏定义

    添加了二级索引结构，系统支持的最大文件体积也增大了，需要在 `kernel/fs.h` 修改文件能达到的最大体积的宏定义

    ````C
    #define MAXFILE (NDIRECT + NINDIRECT + NDOUBLYINDIRECT) // 文件最大体积
    ````


#### 2.2. 程序测试

启动xv6,输入指令`bigfile`进行测试。

```
$ bigfile
..................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
wrote 65803 blocks
bigfile done; ok
$
```

### 3. 注意事项和提示

* 确保您了解`bmap（）`。 写下`ip-> addrs []`，它所指向的间接块，双间接块和单间接块与数据块之间的关系图。 确保您了解为什么添加双间接块会使最大文件大小增加256 * 256块（实际上是-1，因为必须将直接块的数量减少一个）。

* 考虑一下如何用逻辑块号索引双间接块及其指向的间接块。

* 如果更改`NDIRECT`的定义，则可能必须在`file.h`的`struct inode`中更改`addrs []`的声明。 确保`struct inode`和`struct dinode`在其`addrs []`数组中具有相同数量的元素。

* 如果更改`NDIRECT`的定义，请确保创建一个新的`fs.img`，因为`mkfs`使用`NDIRECT`来构建文件系统。

* 如果文件系统进入故障状态（可能是崩溃），则删除`fs.img`（从Unix而非xv6执行此操作）。 make将为您构建一个新的干净文件系统映像。

* 别忘了`brelse（）``bread（）`的每个块。

* 您仅应根据需要分配间接块和双间接块，例如原始的`bmap（）`。

* 确保`itrunc`释放文件的所有块，包括双间接块。

## 二. Symbolic links ([moderate](https://pdos.csail.mit.edu/6.828/2020/labs/guidance.html))

### 1. 实验要求

在本练习中，您将向xv6添加符号链接。 符号链接（或软链接）通过路径名引用链接的文件。 当打开符号链接时，内核将链接指向引用的文件。 符号链接类似于硬链接，但是硬链接仅限于指向同一磁盘上的文件，而符号链接可以跨磁盘设备。 尽管xv6不支持多个设备，但是实现此系统调用是了解路径名查找如何工作的一个好习惯。

### 2. 实验步骤

#### 2.1. 编写代码及配置

+ 添加`symlink`的定义声明

    下面是有关 `symlink` 系统调用的定义声明

    ````C
    // kernel/syscall.h
    #define SYS_close  21
    #define SYS_symlink 22//new
    
    
    //kernel/syscall.c
    extern uint64 sys_uptime(void);
    extern uint64 sys_symlink(void);//new 
    //...
    [SYS_close]   sys_close,
    [SYS_symlink] sys_symlink,//new
    };
    
    
    //user/usys.pl
    entry("uptime");
    entry("symlink");
    
    
    //user/user.h
    int uptime(void);
    int symlink(char *target, char *path);//new
    ````


+ 在`kernel/stat.h`添加新的文件类型`T_SYMLINK`

    ````C
    #define T_SYMLINK 4	//软链接
    ````

+ 在`kernel/fcntl.h` 中添加新的文件标志位 `O_NOFOLLOW` 

    ````C
    #define O_NOFOLLOW 0x004	//new
    ````

+ 实现 `sys_symlink()` 

    这个函数用于生成符号链接。符号链接本身也看做是一个文件，即符号链接本身也有自己的`dinode`和`inode`，其文件内容也只是一行字符串，表征着符号链接指向的文件的路径。创建符号链接时，要为其分配一个`inode`。

    在该函数中, 首先通过 `create() `创建符号链接路径对应的` inode `结构。然后再通过 `writei()` 将链接的目标文件的路径写入` inode` 的块中即可. 在这个过程中, 无需判断连接的目标路径是否有效。`writei()` 是需要在持锁的情况下才能写入. 在结束操作后(不论成功与否), 都需要调用 `iunlockput()` 来释放` inode `的锁和其本身。

    在 `kernel/sysfile.c` 中实现`sys_symlink`函数。

    ```
    // new 
    uint64
    sys_symlink(void) {
      char target[MAXPATH], path[MAXPATH];
      struct inode *ip;
      int n;
    
      if ((n = argstr(0, target, MAXPATH)) < 0
        || argstr(1, path, MAXPATH) < 0) {
        return -1;
      }
    
      begin_op();
      // 创建符号链接
      if((ip = create(path, T_SYMLINK, 0, 0)) == 0) {
        end_op();
        return -1;
      }
      // 写入目标路径
      if(writei(ip, 0, (uint64)target, 0, n) != n) {
        iunlockput(ip);
        end_op();
        return -1;
      }
    
      iunlockput(ip);
      end_op();
      return 0;
    }
    ```

+ 修改`sys_open()`函数，实现有符号链接情况下的文件打开。

    `sys_open()`函数它的功能是打开文件，对于符号链接需要特殊处理，打开的是链接指向的目标文件。

    为了寻找符号链接的目标文件，此处封装了一个独立的函数`follow_symlink()`。考虑到符号链接的目标文件可能还是符号链接，需要递归的寻找，这就带来两个问题：一是符号链接可能成环，需要检测是否成死循环；二是需要限制链接深度。

    对于链接深度，在 `kernel/fs.h` 中定义了 `NSYMLINK` 用于表示最大的符号链接深度, 超过该深度将不会继续跟踪而是返回错误.

    ````C
    // 符号链接最大深度
    #define NSYMLINK 10
    ````

    处理成环检测，则使用下面的办法：创建一个大小为 `NSYMLINK` 的数组 `inums` ，记录每次跟踪到的文件的 `inode number`，每次寻找到一个目标文件后，用这个文件的 `inode number`去`inums`数组中查找，若有搜索到相同的则说明成环。

    `follow_symlink()`函数限制递归深度，最多进行 `NSYMLINK` 次迭代，通过递归的方式跟踪符号链接的目标文件，并在递归过程中使用 `inums` 数组记录已访问过的 inode 号，从而进行成环检测。

    ```
    static struct inode* follow_symlink(struct inode* ip) {
      uint inums[NSYMLINK];
      int i, j;
      char target[MAXPATH];
    
      for(i = 0; i < NSYMLINK; ++i) {
        inums[i] = ip->inum;
        // 获取目标文件路径
        if(readi(ip, 0, (uint64)target, 0, MAXPATH) <= 0) {
          iunlockput(ip);
          printf("open_symlink: open symlink failed\n");
          return 0;
        }
        iunlockput(ip);
        
        // 获取目标文件的inode
        if((ip = namei(target)) == 0) {
          printf("open_symlink: path \"%s\" is not exist\n", target);
          return 0;
        }
        for(j = 0; j <= i; ++j) {
          if(ip->inum == inums[j]) {
            printf("open_symlink: links form a cycle\n");
            return 0;
          }
        }
        ilock(ip);
        if(ip->type != T_SYMLINK) {
          return ip;
        }
      }
    
      iunlockput(ip);
      printf("open_symlink: the depth of links reaches the limit\n");
      return 0;
    }
    ```

+ 修改`sys_open()`文件，在非 `NO_FOLLOW` 的情况下需要将当前文件的`inode`替换为由 `follow_symlink()` 得到的目标文件的 `inode` 再进行后续的操作。

    ```
    uint64
    sys_open(void)
    {
      //...
      if(ip->type == T_DEVICE && (ip->major < 0 || ip->major >= NDEV)){
        iunlockput(ip);
        end_op();
        return -1;
      }
    
      // lab 9-2 add
      // 符号链接
      if(ip->type == T_SYMLINK && (omode & O_NOFOLLOW) == 0) {
        if((ip = follow_symlink(ip)) == 0) {
          end_op();
          return -1;
        }
      }
    
      if((f = filealloc()) == 0 || (fd = fdalloc(f)) < 0){
        if(f)
          fileclose(f);
        iunlockput(ip);
        end_op();
        return -1;
      }
    //...
    
    ```

+ 在 `Makefile` 中添加对测试文件 `symlinktest.c` 的编译

    ````makefile
    $U/_symlinktest\
    ````


#### 2.2. 程序测试

启动xv6,输入指令`symlinktest `进行测试。

```
$ symlinktest
Start: test symlinks
open_symlink: path "/testsymlink/a" is not exist
open_symlink: links form a cycle
test symlinks: ok
Start: test concurrent symlinks
test concurrent symlinks: ok
```

输入指令`usertests `进行测试。

```
$ usertests
usertests starting
test manywrites: OK
test execout: OK
test copyin: OK
test copyout: OK
test copyinstr1: OK
test copyinstr2: OK
test copyinstr3: OK
test rwsbrk: OK
test truncate1: OK
test truncate2: OK
test truncate3: OK
test reparent2: OK
test pgbug: OK
test sbrkbugs: usertrap(): unexpected scause 0x000000000000000c pid=3244
            sepc=0x00000000000056a6 stval=0x00000000000056a6
usertrap(): unexpected scause 0x000000000000000c pid=3245
            sepc=0x00000000000056a6 stval=0x00000000000056a6
OK
test badarg: OK
test reparent: OK
test twochildren: OK
test forkfork: OK
test forkforkfork: OK
test argptest: OK
test createdelete: OK
test linkunlink: OK
test linktest: OK
test unlinkread: OK
test concreate: OK
test subdir: OK
test fourfiles: OK
test sharedfd: OK
test dirtest: OK
test exectest: OK
test bigargtest: OK
test bigwrite: OK
test bsstest: OK
test sbrkbasic: OK
test sbrkmuch: OK
test kernmem: usertrap(): unexpected scause 0x000000000000000d pid=6171
            sepc=0x000000000000215e stval=0x0000000080000000
usertrap(): unexpected scause 0x000000000000000d pid=6172
            sepc=0x000000000000215e stval=0x000000008000c350
usertrap(): unexpected scause 0x000000000000000d pid=6173
            sepc=0x000000000000215e stval=0x00000000800186a0
usertrap(): unexpected scause 0x000000000000000d pid=6174
            sepc=0x000000000000215e stval=0x00000000800249f0
usertrap(): unexpected scause 0x000000000000000d pid=6175
            sepc=0x000000000000215e stval=0x0000000080030d40
usertrap(): unexpected scause 0x000000000000000d pid=6176
            sepc=0x000000000000215e stval=0x000000008003d090
usertrap(): unexpected scause 0x000000000000000d pid=6177
            sepc=0x000000000000215e stval=0x00000000800493e0
usertrap(): unexpected scause 0x000000000000000d pid=6178
            sepc=0x000000000000215e stval=0x0000000080055730
usertrap(): unexpected scause 0x000000000000000d pid=6179
            sepc=0x000000000000215e stval=0x0000000080061a80
usertrap(): unexpected scause 0x000000000000000d pid=6180
            sepc=0x000000000000215e stval=0x000000008006ddd0
usertrap(): unexpected scause 0x000000000000000d pid=6181
            sepc=0x000000000000215e stval=0x000000008007a120
usertrap(): unexpected scause 0x000000000000000d pid=6182
            sepc=0x000000000000215e stval=0x0000000080086470
usertrap(): unexpected scause 0x000000000000000d pid=6183
            sepc=0x000000000000215e stval=0x00000000800927c0
usertrap(): unexpected scause 0x000000000000000d pid=6184
            sepc=0x000000000000215e stval=0x000000008009eb10
usertrap(): unexpected scause 0x000000000000000d pid=6185
            sepc=0x000000000000215e stval=0x00000000800aae60
usertrap(): unexpected scause 0x000000000000000d pid=6186
            sepc=0x000000000000215e stval=0x00000000800b71b0
usertrap(): unexpected scause 0x000000000000000d pid=6187
            sepc=0x000000000000215e stval=0x00000000800c3500
usertrap(): unexpected scause 0x000000000000000d pid=6188
            sepc=0x000000000000215e stval=0x00000000800cf850
usertrap(): unexpected scause 0x000000000000000d pid=6189
            sepc=0x000000000000215e stval=0x00000000800dbba0
usertrap(): unexpected scause 0x000000000000000d pid=6190
            sepc=0x000000000000215e stval=0x00000000800e7ef0
usertrap(): unexpected scause 0x000000000000000d pid=6191
            sepc=0x000000000000215e stval=0x00000000800f4240
usertrap(): unexpected scause 0x000000000000000d pid=6192
            sepc=0x000000000000215e stval=0x0000000080100590
usertrap(): unexpected scause 0x000000000000000d pid=6193
            sepc=0x000000000000215e stval=0x000000008010c8e0
usertrap(): unexpected scause 0x000000000000000d pid=6194
            sepc=0x000000000000215e stval=0x0000000080118c30
usertrap(): unexpected scause 0x000000000000000d pid=6195
            sepc=0x000000000000215e stval=0x0000000080124f80
usertrap(): unexpected scause 0x000000000000000d pid=6196
            sepc=0x000000000000215e stval=0x00000000801312d0
usertrap(): unexpected scause 0x000000000000000d pid=6197
            sepc=0x000000000000215e stval=0x000000008013d620
usertrap(): unexpected scause 0x000000000000000d pid=6198
            sepc=0x000000000000215e stval=0x0000000080149970
usertrap(): unexpected scause 0x000000000000000d pid=6199
            sepc=0x000000000000215e stval=0x0000000080155cc0
usertrap(): unexpected scause 0x000000000000000d pid=6200
            sepc=0x000000000000215e stval=0x0000000080162010
usertrap(): unexpected scause 0x000000000000000d pid=6201
            sepc=0x000000000000215e stval=0x000000008016e360
usertrap(): unexpected scause 0x000000000000000d pid=6202
            sepc=0x000000000000215e stval=0x000000008017a6b0
usertrap(): unexpected scause 0x000000000000000d pid=6203
            sepc=0x000000000000215e stval=0x0000000080186a00
usertrap(): unexpected scause 0x000000000000000d pid=6204
            sepc=0x000000000000215e stval=0x0000000080192d50
usertrap(): unexpected scause 0x000000000000000d pid=6205
            sepc=0x000000000000215e stval=0x000000008019f0a0
usertrap(): unexpected scause 0x000000000000000d pid=6206
            sepc=0x000000000000215e stval=0x00000000801ab3f0
usertrap(): unexpected scause 0x000000000000000d pid=6207
            sepc=0x000000000000215e stval=0x00000000801b7740
usertrap(): unexpected scause 0x000000000000000d pid=6208
            sepc=0x000000000000215e stval=0x00000000801c3a90
usertrap(): unexpected scause 0x000000000000000d pid=6209
            sepc=0x000000000000215e stval=0x00000000801cfde0
usertrap(): unexpected scause 0x000000000000000d pid=6210
            sepc=0x000000000000215e stval=0x00000000801dc130
OK
test sbrkfail: usertrap(): unexpected scause 0x000000000000000d pid=6218
            sepc=0x00000000000041fe stval=0x0000000000012000
OK
test sbrkarg: OK
test validatetest: OK
test stacktest: usertrap(): unexpected scause 0x000000000000000d pid=6222
            sepc=0x00000000000022ce stval=0x000000000000fb90
OK
test opentest: OK
test writetest: OK
test writebig: OK
test createtest: OK
test openiput: OK
test exitiput: OK
test iput: OK
test mem: OK
test pipe1: OK
test preempt: kill... wait... OK
test exitwait: OK
test rmdot: OK
test fourteen: OK
test bigfile: OK
test dirfile: OK
test iref: OK
test forktest: OK
test bigdir: OK
ALL TESTS PASSED
$
```

### 3. 注意事项和提示

您将实现`symlink（char * target，char * path`）系统调用，该系统调用将在引用由`target`命名的文件的路径上创建一个新的符号链接。 有关更多信息，请参见手册页符号链接。 要进行测试，请将`symlinktest`添加到`Makefile`并运行它。 当测试产生以下输出（包括后续的用户测试）时，您的解决方案即告完成。

````bash
$ symlinktest
Start: test symlinks
test symlinks: ok
Start: test concurrent symlinks
test concurrent symlinks: ok
$ usertests
...
ALL TESTS PASSED
$ 
````

* 首先，为`symlink`创建一个新的系统调用号，在`user / usys.pl`，`user / user.h`中添加一个条目，并在`kernel / sysfile.c`中实现一个空的`sys_symlink`。

* 将新文件类型（`T_SYMLINK`）添加到`kernel / stat.h`中以表示符号链接。

* 在`kernel / fcntl.h`中添加一个新标志（`O_NOFOLLOW`），该标志可以与开放系统调用一起使用。 请注意，传递给`open`的标志是使用按位`OR`运算符组合的，因此您的新标志不应与任何现有标志重叠。 一旦将它添加到`Makefile`中，就可以编译`user / symlinktest.c`。

* 实现`symlink（target，path）`系统调用，以在引用目标的路径上创建一个新的符号链接。 请注意，目标不需要存在即可成功进行系统调用。 您将需要选择某个位置来存储符号链接的目标路径，例如，存储在`inode`的数据块中。` symlink`应该返回一个类似于链接和取消链接的表示成功（0）或失败（-1）的整数。

* 修改开放系统调用以处理路径引用符号链接的情况。 如果文件不存在，则打开必须失败。 当进程在要打开的标志中指定`O_NOFOLLOW`时，`open`应该打开符号链接（而不是跟随符号链接）。

* 如果链接文件也是符号链接，则必须递归地跟随它，直到到达非链接文件为止。 如果链接形成循环，则必须返回错误代码。 如果链接的深度达到某个阈值（例如10），则可以通过返回错误代码来近似估算。

* 其他系统调用（例如链接和取消链接）不得跟随符号链接； 这些系统调用在符号链接本身上运行。

* 您不必处理此实验的目录符号链接。

## 三. 总实验结果

在目录下创建`time.txt`，并输入完成实验的小时数。在终端执行

```
 ./grade-lab-fs
```

来对实验结果进行完全测试。

测试结果如下：

```
make: 'kernel/kernel' is up to date.
== Test running bigfile == running bigfile: OK (48.3s)
== Test running symlinktest == (1.0s)
== Test   symlinktest: symlinks ==
  symlinktest: symlinks: OK
== Test   symlinktest: concurrent symlinks ==
  symlinktest: concurrent symlinks: OK
== Test usertests == usertests: OK (161.6s)
== Test time ==
time: OK
Score: 100/100
```

## 四. 遇到的问题及解决方法

xv6启动死循环

在完成第二个实验的代码后，启动xv6进行测试，发现xv6启动失败，shell不断打印`init: starting sh`，陷入死循环。推测为手误导致。

解决方法：重新clone实验代码，从头开始实验。



# Lab10. mmap

## 一. mmap ([hard](https://pdos.csail.mit.edu/6.828/2020/labs/guidance.html))

### 1. 实验要求

在实验环境中实现 `mmap()` 系统调用。

`mmap`和`munmap`系统调用允许UNIX程序对其地址空间进行详细控制。 它们可用于在进程之间共享内存，将文件映射到进程地址空间，以及作为用户级页面错误方案的一部分。在本实验中，您将向xv6添加`mmap`和`munmap`，重点是内存映射文件。

### 2. 实验步骤

#### 2.1. 编写代码及配置

+ 添加系统调用的定义

    需要新增的系统调用有`mmap`和`munmap`，需要在多处修改添加相关定义

    在`kernel/syscall.h`添加两个新的系统调用号。

    ````c
    #define SYS_mmap   22   // 新的系统调用号
    #define SYS_munmap 23   
    ````

    `kernel/syscall.c`添加引用声明

    ````c
    extern uint64 sys_mmap(void);       // new 
    extern uint64 sys_munmap(void);     
    ````

    `user/usys.pl`加入系统调用的入口

    ````c
    entry("mmap");      # new entry
    entry("munmap");    
    ````

    `user/user.h`添加函数定义

    ````c
    void *mmap(void *addr, int length, int prot, int flags,
               int fd, int offset);     // new
    int munmap(void *add, int length);  
    ````

    `Makefile`的`UPROGS`添加`mmaptest`

    ````makefile
    	$U/_mmaptest
    ````

+ 定义虚拟内存区域的结构体和数组

    **Virtual Memory Area, VMA**，指使用 `mmap` 系统调用文件映射的虚拟内存区域，其中包含了如位置、容量大小、权限等信息。在`kernel/proc.h`定义`vm_area`结构体来作为VMA，包括内存信息、mmap映射的起始地址、mmap映射内存的大小、用户的权限、mmap标志位、文件的偏移量、文件结构体指针。

    ````C
    //VMA定义
    struct vm_area {
        uint64 addr;    // mmap映射的起始地址
        int len;    // mmap映射内存的大小
        int prot;   // 用户的权限
        int flags;  // mmap标志位
        int offset; // 文件的偏移量
        struct file* f;     //文件结构体指针
    };
    ````

+ 修改进程结构体

    为完成mmap的功能，每个进程都需要一个VMA数组来记录它所映射的内存。在`kernell/proc.h`的进程结构体`proc`中，新增了VMA的数组`vma`，他的大小设计为`NVMA`，在头部定义为16。

    ````c
    #define NVMA 16     // vma数组大小
    
    // Per-process state
    struct proc {
      // ...
      struct inode *cwd;           // Current directory
      char name[16];               // Process name (debugging)
      struct vm_area vma[NVMA];    // VMA数组
    };
    ````

+ 实现`mmap`系统调用

    需要在 `kernel/sysfile.c` 中实现系统调用 `sys_mmap()`。由于这个系统调用对文件映射的内存采用了lazy分配，在访问文件映射的内存时，需要处理lazy allocation机制产生的page default，即修改`kernel/trap.c`中的`usertrap（）`函数。下面是`usertrap`的处理思路

    首先要确定page fault 的情况有哪几种，在mmap机制中，映射的内存是还不存在的，内存的读写执行三种情况都有可能发生，对应就是`r_scause()`的值可以是12、13、15。

    接着要根据发生缺页的地址，在当前进程的VMA数组中拿到对应的VMA结构体，找到了对应的VMA，也说明这次缺页是mmap机制访问文件映射的内存而产生的。

    下面进行lazy 分配物理页，再使用`readi（）`，根据缺页发生的地址，从文件中读取内容到分配好的物理页面。读取的内容大小为`PGSIZE`，超出文件大小的部分会在`readi`中截取，并注意读取前后需要对文件的`inode`加锁保护，因为这个操作可能并行进行。

    读取完毕后，根据操作的不同，给VMA设置好对应的访问权限。最后用`mappages`函数将物理页映射到用户进程的页面。

    ```
    //kernel/trap.c
    void
    usertrap(void)
    {
      // ...
      if(r_scause() == 8){
        // ...
      } else if (r_scause() == 12 || r_scause() == 13
                 || r_scause() == 15) { //mmap的缺页
        char *pa;
        uint64 va = PGROUNDDOWN(r_stval());
        struct vm_area *vma = 0;
        int flags = PTE_U;
        int i;
        // 找到对应的VMA结构
        for (i = 0; i < NVMA; ++i) {
    
          if (p->vma[i].addr && va >= p->vma[i].addr
              && va < p->vma[i].addr + p->vma[i].len) {
            vma = &p->vma[i];
            break;
          }
        }
        if (!vma) {
          goto err;
        }
        // 设置权限标志
        if (r_scause() == 15 && (vma->prot & PROT_WRITE)
            && walkaddr(p->pagetable, va)) {
          if (uvmsetdirtywrite(p->pagetable, va)) {
            goto err;
          }
        } else {
          if ((pa = kalloc()) == 0) {
            goto err;
          }
          memset(pa, 0, PGSIZE);
          ilock(vma->f->ip);
          if (readi(vma->f->ip, 0, (uint64) pa, va - vma->addr + vma->offset, PGSIZE) < 0) {
            iunlock(vma->f->ip);
            goto err;
          }
          iunlock(vma->f->ip);
          if ((vma->prot & PROT_READ)) {
            flags |= PTE_R;
          }
    
          if (r_scause() == 15 && (vma->prot & PROT_WRITE)) {
            flags |= PTE_W | PTE_D;
          }
          if ((vma->prot & PROT_EXEC)) {
            flags |= PTE_X;
          }
          if (mappages(p->pagetable, va, PGSIZE, (uint64) pa, flags) != 0) {
            kfree(pa);
            goto err;
          }
        }
      }else if((which_dev = devintr()) != 0){
        // ok
      } else {
    err:
        printf("usertrap(): unexpected scause %p pid=%d\n", r_scause(), p->pid);
        printf("            sepc=%p stval=%p\n", r_sepc(), r_stval());
        p->killed = 1;
      }
      // ...
    }  
    
    ```

+ 实现`munmap`系统调用

    在 `kernel/sysfile.c` 中实现系统调用 `sys_munmap()`。

    这个系统调用会取消映射的内存，如果取消的内存部分有`MAP_SHARED`标志位，还需要把对文件映射的内存的修改回写到原文件中。

    实现`sys_munmap()`系统调用，简单地获取参数并检查合法性后，根据变量`addr`和`length`在进程中寻找对应的VMA结构体，若没找到则直接返回失败。

    接着判断这块要取消映射的内存部分是不是有 `MAP_SHARED` 标志位，有的话需要将该部分写回原来的文件。对于写回文件这部分，根据实验指导, 选择使用脏页标志位`PTE_D`进行记录。存在该标志位，说明这部分被修改过（脏过），那么就需要写回，若没有则不需要写回。此外，一次写入文件的大小还受日志`block`的影响, 因此可能会再分批次写入文件。

    ```
    // munmap系统调用
    uint64 sys_munmap(void) {
      uint64 addr, va;
      int len;
      struct proc *p = myproc();
      struct vm_area *vma = 0;
      uint maxsz, n, n1;
      int i;
    //判断参数合法性
      if (argaddr(0, &addr) < 0 || argint(1, &len) < 0) {
        return -1;
      }
      if (addr % PGSIZE || len < 0) {
        return -1;
      }
    
      // 寻找对应的VMA
      for (i = 0; i < NVMA; ++i) {
        if (p->vma[i].addr && addr >= p->vma[i].addr
            && addr + len <= p->vma[i].addr + p->vma[i].len) {
          vma = &p->vma[i];
          break;
        }
      }
       //无VMA，直接返回失败
      if (!vma) {
        return -1;
      }
    
      if (len == 0) {
        return 0;
      }
    
      if ((vma->flags & MAP_SHARED)) {
        // 一次能写入的最大长度
        maxsz = ((MAXOPBLOCKS - 1 - 1 - 2) / 2) * BSIZE;
        for (va = addr; va < addr + len; va += PGSIZE) {
          if (uvmgetdirty(p->pagetable, va) == 0) {
            continue;
          }
          
          n = min(PGSIZE, addr + len - va);
          for (i = 0; i < n; i += n1) {
            n1 = min(maxsz, n - i);
            begin_op();
            ilock(vma->f->ip);
            if (writei(vma->f->ip, 1, va + i, va - vma->addr + vma->offset + i, n1) != n1) {
              iunlock(vma->f->ip);
              end_op();
              return -1;
            }
            iunlock(vma->f->ip);
            end_op();
          }
        }
      }
      uvmunmap(p->pagetable, addr, (len - 1) / PGSIZE + 1, 1);
      // 更新VMA
      if (addr == vma->addr && len == vma->len) {
        vma->addr = 0;
        vma->len = 0;
        vma->offset = 0;
        vma->flags = 0;
        vma->prot = 0;
        fileclose(vma->f);
        vma->f = 0;
      } else if (addr == vma->addr) {
        vma->addr += len;
        vma->offset += len;
        vma->len -= len;
      } else if (addr + len == vma->addr + vma->len) {
        vma->len -= len;
      } else {
        panic("unexpected munmap");
      }
      return 0;
    }
    
    ```

    将修改内容写回文件后，使用`uvmunmap（）`取消掉这部分页面在用户页表中的映射。同时`uvmunmap()` 函数的 `PTE_V` 标志位的检查部分需要进行相应的修改，若取消映射的页面没有实际分配物理页，直接跳过即可。

    ```
    //kernel/sysfile.c
    void
    uvmunmap(pagetable_t pagetable, uint64 va, uint64 npages, int do_free)
    {
      // ...
      for(a = va; a < va + npages*PGSIZE; a += PGSIZE){
        if((pte = walk(pagetable, a, 0)) == 0)
          panic("uvmunmap: walk");
        if((*pte & PTE_V) == 0) {
          continue;   // lab10
    //      panic("uvmunmap: not mapped");  
        }
        if(PTE_FLAGS(*pte) == PTE_V) {
          continue;   
    //      panic("uvmunmap: not a leaf");
        }
        // ...
      }
    }
    
    ```

+ 脏页标志位

    上一步中`munmap`系统调用将映射内存中修改的内容写回文件时，是根据脏页进行写回的，那么这里就要完成脏页标志位的设置。

    在 `kernel/riscv.h` 中定义脏页标志位 `PTE_D`

    ````c
    #define PTE_D (1L << 7) // 脏页标志位
    ````

    在 `kernel/vm.c` 新增两个函数 `uvmgetdirty()` 、 `uvmsetdirtywrite()` 。前者用于读取脏页标志位，后者写入脏页标志位和写标志位。

    ```
    // 取脏页标志位
    int uvmgetdirty(pagetable_t pagetable, uint64 va) {
      pte_t *pte = walk(pagetable, va, 0);
      if(pte == 0) {
        return 0;
      }
      return (*pte & PTE_D);
    }
    
    // 写入脏页标志位和写标志位
    int uvmsetdirtywrite(pagetable_t pagetable, uint64 va) {
      pte_t *pte = walk(pagetable, va, 0);
      if(pte == 0) {
        return -1;
      }
      *pte |= PTE_D | PTE_W;
      return 0;
    }
    ```

+ 修改 `exit` 和 `fork` 系统调用

    最后需要修改 `exit` 和 `fork` 系统调用，完成对进程文件映射内存和VMA 数组的处理。

    对`exit（）`函数，它关系到进程的退出，此时需要遍历VMA数组，取消掉所有文件映射内存的映射。

    ```
    void
    exit(int status)
    {
      // ...
      if(p == initproc)
        panic("init exiting");
    
      // 取消所有映射
      for (i = 0; i < NVMA; ++i) {
        if (p->vma[i].addr == 0) {
          continue;
        }
        vma = &p->vma[i];
        if ((vma->flags & MAP_SHARED)) {
          for (va = vma->addr; va < vma->addr + vma->len; va += PGSIZE) {
            if (uvmgetdirty(p->pagetable, va) == 0) {
              continue;
            }
            n = min(PGSIZE, vma->addr + vma->len - va);
            for (r = 0; r < n; r += n1) {
              n1 = min(maxsz, n - i);
              begin_op();
              ilock(vma->f->ip);
              if (writei(vma->f->ip, 1, va + i, va - vma->addr + vma->offset + i, n1) != n1) {
                iunlock(vma->f->ip);
                end_op();
                panic("exit: writei failed");
              }
              iunlock(vma->f->ip);
              end_op();
            }
          }
        }
        uvmunmap(p->pagetable, vma->addr, (vma->len - 1) / PGSIZE + 1, 1);
        vma->addr = 0;
        vma->len = 0;
        vma->offset = 0;
        vma->flags = 0;
        vma->offset = 0;
        fileclose(vma->f);
        vma->f = 0;
      }
    
      // Close all open files.
      for(int fd = 0; fd < NOFILE; fd++){
        if(p->ofile[fd]){
          struct file *f = p->ofile[fd];
          fileclose(f);
          p->ofile[fd] = 0;
        }
      }
      // ...
    }
    ```

    对于`fork（）`函数，它负责创建进程。创建子进程时, 需要将父进程的 VMA 结构体进行拷贝, 子进程获得与父进程相同的文件映射内存，直接将父进程的 VMA 数组复制到子进程中即可。

    ```
    int
    fork(void)
    {
      // ...
      // increment reference counts on open file descriptors.
      for(i = 0; i < NOFILE; i++)
        if(p->ofile[i])
          np->ofile[i] = filedup(p->ofile[i]);
      np->cwd = idup(p->cwd);
    
      // 复制粘贴父进程的所有VMA
      for (i = 0; i < NVMA; ++i) {
        if (p->vma[i].addr) {
          np->vma[i] = p->vma[i];
          filedup(np->vma[i].f);
        }
      }
    
      safestrcpy(np->name, p->name, sizeof(p->name));
      // ...
    }
    ```

#### 2.2. 程序测试

启动xv6,输入指令`mmaptest`进行测试。

```
$ mmaptest
mmap_test starting
test mmap f
test mmap f: OK
test mmap private
test mmap private: OK
test mmap read-only
test mmap read-only: OK
test mmap read/write
test mmap read/write: OK
test mmap dirty
test mmap dirty: OK
test not-mapped unmap
test not-mapped unmap: OK
test mmap two files
test mmap two files: OK
mmap_test: ALL OK
fork_test starting
fork_test OK
mmaptest: all tests succeeded
```

输入指令`usertests`进行测试

```
$ usertests
usertests starting
test manywrites: OK
test execout: OK
test copyin: OK
test copyout: OK
test copyinstr1: OK
test copyinstr2: OK
test copyinstr3: OK
test rwsbrk: OK
test truncate1: OK
test truncate2: OK
test truncate3: OK
test reparent2: OK
test pgbug: OK
test sbrkbugs: usertrap(): unexpected scause 0x000000000000000c pid=3242
            sepc=0x00000000000056a4 stval=0x00000000000056a4
usertrap(): unexpected scause 0x000000000000000c pid=3243
            sepc=0x00000000000056a4 stval=0x00000000000056a4
OK
test badarg: OK
test reparent: OK
test twochildren: OK
test forkfork: OK
test forkforkfork: OK
test argptest: OK
test createdelete: OK
test linkunlink: OK
test linktest: OK
test unlinkread: OK
test concreate: OK
test subdir: OK
test fourfiles: OK
test sharedfd: OK
test dirtest: OK
test exectest: OK
test bigargtest: OK
test bigwrite: OK
test bsstest: OK
test sbrkbasic: OK
test sbrkmuch: OK
test kernmem: usertrap(): unexpected scause 0x000000000000000d pid=6223
            sepc=0x000000000000215c stval=0x0000000080000000
usertrap(): unexpected scause 0x000000000000000d pid=6224
            sepc=0x000000000000215c stval=0x000000008000c350
usertrap(): unexpected scause 0x000000000000000d pid=6225
            sepc=0x000000000000215c stval=0x00000000800186a0
usertrap(): unexpected scause 0x000000000000000d pid=6226
            sepc=0x000000000000215c stval=0x00000000800249f0
usertrap(): unexpected scause 0x000000000000000d pid=6227
            sepc=0x000000000000215c stval=0x0000000080030d40
usertrap(): unexpected scause 0x000000000000000d pid=6228
            sepc=0x000000000000215c stval=0x000000008003d090
usertrap(): unexpected scause 0x000000000000000d pid=6229
            sepc=0x000000000000215c stval=0x00000000800493e0
usertrap(): unexpected scause 0x000000000000000d pid=6230
            sepc=0x000000000000215c stval=0x0000000080055730
usertrap(): unexpected scause 0x000000000000000d pid=6231
            sepc=0x000000000000215c stval=0x0000000080061a80
usertrap(): unexpected scause 0x000000000000000d pid=6232
            sepc=0x000000000000215c stval=0x000000008006ddd0
usertrap(): unexpected scause 0x000000000000000d pid=6233
            sepc=0x000000000000215c stval=0x000000008007a120
usertrap(): unexpected scause 0x000000000000000d pid=6234
            sepc=0x000000000000215c stval=0x0000000080086470
usertrap(): unexpected scause 0x000000000000000d pid=6235
            sepc=0x000000000000215c stval=0x00000000800927c0
usertrap(): unexpected scause 0x000000000000000d pid=6236
            sepc=0x000000000000215c stval=0x000000008009eb10
usertrap(): unexpected scause 0x000000000000000d pid=6237
            sepc=0x000000000000215c stval=0x00000000800aae60
usertrap(): unexpected scause 0x000000000000000d pid=6238
            sepc=0x000000000000215c stval=0x00000000800b71b0
usertrap(): unexpected scause 0x000000000000000d pid=6239
            sepc=0x000000000000215c stval=0x00000000800c3500
usertrap(): unexpected scause 0x000000000000000d pid=6240
            sepc=0x000000000000215c stval=0x00000000800cf850
usertrap(): unexpected scause 0x000000000000000d pid=6241
            sepc=0x000000000000215c stval=0x00000000800dbba0
usertrap(): unexpected scause 0x000000000000000d pid=6242
            sepc=0x000000000000215c stval=0x00000000800e7ef0
usertrap(): unexpected scause 0x000000000000000d pid=6243
            sepc=0x000000000000215c stval=0x00000000800f4240
usertrap(): unexpected scause 0x000000000000000d pid=6244
            sepc=0x000000000000215c stval=0x0000000080100590
usertrap(): unexpected scause 0x000000000000000d pid=6245
            sepc=0x000000000000215c stval=0x000000008010c8e0
usertrap(): unexpected scause 0x000000000000000d pid=6246
            sepc=0x000000000000215c stval=0x0000000080118c30
usertrap(): unexpected scause 0x000000000000000d pid=6247
            sepc=0x000000000000215c stval=0x0000000080124f80
usertrap(): unexpected scause 0x000000000000000d pid=6248
            sepc=0x000000000000215c stval=0x00000000801312d0
usertrap(): unexpected scause 0x000000000000000d pid=6249
            sepc=0x000000000000215c stval=0x000000008013d620
usertrap(): unexpected scause 0x000000000000000d pid=6250
            sepc=0x000000000000215c stval=0x0000000080149970
usertrap(): unexpected scause 0x000000000000000d pid=6251
            sepc=0x000000000000215c stval=0x0000000080155cc0
usertrap(): unexpected scause 0x000000000000000d pid=6252
            sepc=0x000000000000215c stval=0x0000000080162010
usertrap(): unexpected scause 0x000000000000000d pid=6253
            sepc=0x000000000000215c stval=0x000000008016e360
usertrap(): unexpected scause 0x000000000000000d pid=6254
            sepc=0x000000000000215c stval=0x000000008017a6b0
usertrap(): unexpected scause 0x000000000000000d pid=6255
            sepc=0x000000000000215c stval=0x0000000080186a00
usertrap(): unexpected scause 0x000000000000000d pid=6256
            sepc=0x000000000000215c stval=0x0000000080192d50
usertrap(): unexpected scause 0x000000000000000d pid=6257
            sepc=0x000000000000215c stval=0x000000008019f0a0
usertrap(): unexpected scause 0x000000000000000d pid=6258
            sepc=0x000000000000215c stval=0x00000000801ab3f0
usertrap(): unexpected scause 0x000000000000000d pid=6259
            sepc=0x000000000000215c stval=0x00000000801b7740
usertrap(): unexpected scause 0x000000000000000d pid=6260
            sepc=0x000000000000215c stval=0x00000000801c3a90
usertrap(): unexpected scause 0x000000000000000d pid=6261
            sepc=0x000000000000215c stval=0x00000000801cfde0
usertrap(): unexpected scause 0x000000000000000d pid=6262
            sepc=0x000000000000215c stval=0x00000000801dc130
OK
test sbrkfail: usertrap(): unexpected scause 0x000000000000000d pid=6274
            sepc=0x00000000000041fc stval=0x0000000000012000
OK
test sbrkarg: OK
test validatetest: OK
test stacktest: usertrap(): unexpected scause 0x000000000000000d pid=6278
            sepc=0x00000000000022cc stval=0x000000000000fb90
OK
test opentest: OK
test writetest: OK
test writebig: OK
test createtest: OK
test openiput: OK
test exitiput: OK
test iput: OK
test mem: OK
test pipe1: OK
test preempt: kill... wait... OK
test exitwait: OK
test rmdot: OK
test fourteen: OK
test bigfile: OK
test dirfile: OK
test iref: OK
test forktest: OK
test bigdir: OK
ALL TESTS PASSED
```

### 3. 注意事项和提示

手册页（run man 2 mmap）显示了mmap的以下声明：

```c
void *mmap(void *addr, size_t length, int prot, int flags,
           int fd, off_t offset);
```

mmap可以通过多种方式调用，但是本实验仅需要与内存映射文件相关的部分功能。 您可以假设addr始终为零，这意味着内核应确定映射文件的虚拟地址。 mmap返回该地址，如果失败则返回0xffffffffffffffff。 length是要映射的字节数； 它可能与文件的长度不同。 prot指示存储器是否应映射为可读，可写和/或可执行； 您可以假定prot是PROT_READ或PROT_WRITE或两者都是。 标志将为MAP_SHARED（表示对映射内存的修改应写回到文件），或者为MAP_PRIVATE（即不应将其写回文件）。 您不必在标志中实现其他任何位。 fd是要映射的文件的打开文件描述符。 您可以假设offset为零（它是文件中要映射的起点）。

如果映射相同的MAP_SHARED文件的进程不共享物理页面，则可以。

munmap（addr，length）应该删除指定地址范围内的mmap映射。 如果进程已修改内存并映射到MAP_SHARED，则应首先将修改内容写入文件。 munmap调用可能只覆盖了mmap-ed区域的一部分，但是您可以假设它将在开始或结束时取消对整个区域的映射（但不会在区域的中间打孔） 。

您应该实现足够的mmap和munmap功能，以使mmaptest测试程序正常工作。 如果mmaptest不使用mmap功能，则无需实现该功能。

完成后，您应该看到以下输出：

````bash
$ mmaptest
mmap_test starting
test mmap f
test mmap f: OK
test mmap private
test mmap private: OK
test mmap read-only
test mmap read-only: OK
test mmap read/write
test mmap read/write: OK
test mmap dirty
test mmap dirty: OK
test not-mapped unmap
test not-mapped unmap: OK
test mmap two files
test mmap two files: OK
mmap_test: ALL OK
fork_test starting
fork_test OK
mmaptest: all tests succeeded
$ usertests
usertests starting
...
ALL TESTS PASSED
$
````

**提示：**

* 首先将_mmaptest添加到UPROGS，然后进行mmap和munmap系统调用，以便编译user / mmaptest.c。 现在，仅从mmap和munmap返回错误。 我们在kernel / fcntl.h中为您定义了PROT_READ等。 运行mmaptest，它将在第一个mmap调用时失败。

* 响应页面错误，延迟填写页面表。 也就是说，mmap不应分配物理内存或读取文件。 而是像在惰性页面分配实验中一样，在usertrap中的页面错误处理代码中执行此操作（或由usertrap调用）。 懒惰的原因是要确保大文件的mmap很快，并且文件的mmap可能大于物理内存。

* 跟踪每个进程映射的mmap。 定义与第17课中描述的VMA（虚拟内存区域）相对应的结构，记录由mmap创建的虚拟内存范围的地址，长度，权限，文件等。 由于xv6内核在内核中没有内存分配器，因此可以声明一个固定大小的VMA数组并根据需要从该数组进行分配。 大小为16应该足够。

* 实施mmap：在进程的地址空间中找到一个未使用的区域来映射文件，然后将VMA添加到进程的映射区域表中。 VMA应该包含指向要映射的文件的结构文件的指针； mmap应该增加文件的引用计数，以使关闭文件时该结构不会消失（提示：请参见filedup）。 运行mmaptest：第一个mmap应该成功，但是第一次访问mmap-ed内存将导致页面错误并杀死mmaptest。

* 添加代码以使mmap-ed区域中的页面错误分配物理内存页面，将相关文件的4096字节读入该页面，然后将其映射到用户地址空间。 使用readi读取文件，该文件带有一个offset参数，可以在其中读取文件（但您必须锁定/解锁传递给readi的inode）。 不要忘记在页面上正确设置权限。 运行mmaptest; 它应该到达第一个munmap。

* 实施munmap：找到地址范围内的VMA，然后取消映射指定的页面（提示：使用uvmunmap）。 如果munmap删除了先前mmap的所有页面，则应减少相应结构文件的引用计数。 如果未映射的页面已被修改并且文件被映射为MAP_SHARED，则将该页面写回到文件中。 查看文件写入以获取灵感。

* 理想情况下，您的实现只回写程序实际修改的MAP_SHARED页。 RISC-V PTE中的脏位（D）指示是否已写入页面。 但是，mmaptest不会检查是否回写了非脏页； 因此，您无需看D位就可以回写页面。

* 修改出口以取消映射进程的映射区域，就像调用了munmap一样。 运行mmaptest; mmap_test应该通过，但可能不会通过。

* 修改fork以确保子代与父代具有相同的映射区域。 不要忘记为VMA的struct文件增加引用计数。 在子页面错误处理程序中，可以分配一个新的物理页面，而不是与父页面共享页面。 后者会更酷，但需要更多的实施工作。 运行mmaptest; 它应该同时通过mmap_test和fork_test。

* 运行用户测试以确保一切仍然正常。

## 二. 总实验结果

在目录下创建`time.txt`，并输入完成实验的小时数。在终端执行

```
 make grade
```

来对实验结果进行完全测试。

测试结果如下：

```
== Test running mmaptest ==
$ make qemu-gdb
(5.9s)
== Test   mmaptest: mmap f ==
  mmaptest: mmap f: OK
== Test   mmaptest: mmap private ==
  mmaptest: mmap private: OK
== Test   mmaptest: mmap read-only ==
  mmaptest: mmap read-only: OK
== Test   mmaptest: mmap read/write ==
  mmaptest: mmap read/write: OK
== Test   mmaptest: mmap dirty ==
  mmaptest: mmap dirty: OK
== Test   mmaptest: not-mapped unmap ==
  mmaptest: not-mapped unmap: OK
== Test   mmaptest: two files ==
  mmaptest: two files: OK
== Test   mmaptest: fork_test ==
  mmaptest: fork_test: OK
== Test usertests ==
$ make qemu-gdb
usertests: OK (84.2s)
== Test time ==
time: OK
Score: 140/140
```

## 三.遇到的问题及解决方法

mmaptest测试失败

原因是`mmap()` 返回失败，对于没有 `PROT_WRITE` 权限的文件映射, 虽然有 `MAP_SHARED` 标志位, 但并不会写入文件中, 因此应该同样可以继续执行，原先错误地继续按照 `MAP_SHARED` 形式进行映射。

解决方法：添加对映射权限 `prot & PROT_WRITE` 的检查。



# Lab11. networking

## 一. networking ([hard](https://pdos.csail.mit.edu/6.828/2020/labs/guidance.html))

### 1. 实验要求

你的工作是实现网卡的`e1000_transmit()`和`e1000_revc()`，这都在`kernel/e1000.c`中，使得这个驱动能够传输和接收数据包。当`make grade`显示你的方案通过了所有测试，那么表示你的工作完成了。

### 2. 实验步骤

#### 2.1. 编写代码及配置

+ 实现`e1000_transmit`

    在 `kernel/e1000.c` 中实现`e1000_transmit（）`函数，完成发送以太网数据帧到网卡的工作。

    首先，检查网卡的发送缓冲区是否有可用的位置，即检查`E1000_TXD_STAT_DD` 是否被设置，如果没有则返回错误，若发送缓冲区没有溢出，则使用 `mbuffree()` 函数释放最后的已发送但尚未释放的` mbuf`；

    参考 E1000 手册的 Section 3.3，将 `m->head` 指针指向内存中数据包的内容，`m->len` 存储数据包的长度,置描述符的相关标志 `cmd`，并保存指向该 mbuf 的指针，以便稍后释放。

    最后，更新`ring`的索引（`E1000_TDT` 加 11 模 `TX_RING_SIZE`），使网卡知道哪个位置是下一个待发送的数据帧。

    如果`e1000_transmit()`成功地将`mbuf`添加到环中，则返回0。如果失败（例如，没有可用的描述符来传输`mbuf`）.，则返回-1。

    ````c
    int
    e1000_transmit(struct mbuf *m)
    {
      //
      // Your code here.
      //
      // the mbuf contains an ethernet frame; program it into
      // the TX descriptor ring so that the e1000 sends it. Stash
      // a pointer so that it can be freed after sending.
      //
      acquire(&e1000_lock);
      uint32 next_index = regs[E1000_TDT];
      if((tx_ring[next_index].status & E1000_TXD_STAT_DD) == 0){
          release(&e1000_lock);
          return -1;
      }
      if(tx_mbufs[next_index])
          mbuffree(tx_mbufs[next_index]);
      tx_ring[next_index].addr = (uint64)m->head;
      tx_ring[next_index].length = (uint16)m->len;
      tx_ring[next_index].cmd = E1000_TXD_CMD_EOP | E1000_TXD_CMD_RS;
      tx_mbufs[next_index] = m;
      regs[E1000_TDT] = (next_index+1)%TX_RING_SIZE;
      release(&e1000_lock);
      return 0;
    }
    
    ````

+ 实现`e1000_recv`

    首先，通过读取 `E1000_RDT` 控制寄存器，加 11再模 `RX_RING_SIZE`，获取` ring` 索引，索引指向了下个等待接收的` packet`。

    通过检查描述符中 `status` 域的 `E1000_RXD_STAT_DD` 位判断新的 `packet` 是否可用。如果不可用，则停止。否则，就要更新 `mbuf `的 `m->len` 为描述符的 `length` 域。使用 `net_rx()` 将 `mbuf `发给网络栈。

    接着使用`mbufalloc()`分配一个新的`mbuf`，以替换刚刚给`net_rx()`的`mbuf`。将其数据指针（`m->head`）编程到描述符中。将描述符的状态位清除为零。

    最后，更新 `E1000_RDT` 寄存器的值，指向已经处理的最后一个描述符的索引，标志着接收缓冲区已处理数据包的位置。

    ```
    static void
    e1000_recv(void)
    {
      //
      // Your code here.
      //
      // Check for packets that have arrived from the e1000
      // Create and deliver an mbuf for each packet (using net_rx()).
      uint32 next_index = (regs[E1000_RDT]+1)%RX_RING_SIZE;
      while(rx_ring[next_index].status & E1000_RXD_STAT_DD){
        if(rx_ring[next_index].length>MBUF_SIZE){
            panic("MBUF_SIZE OVERFLOW!");
        }
        rx_mbufs[next_index]->len = rx_ring[next_index].length;
        net_rx(rx_mbufs[next_index]);
        rx_mbufs[next_index] =  mbufalloc(0);
        rx_ring[next_index].addr = (uint64)rx_mbufs[next_index]->head;
        rx_ring[next_index].status = 0;
        next_index = (next_index+1)%RX_RING_SIZE;
      }
      regs[E1000_RDT] = (next_index-1)%RX_RING_SIZE;
    }
    ```

#### 2.2. 程序测试

在终端中运行`make server`启动服务器，输出如下：

```
hane7ad@DESKTOP-O1CAKP8:~/xv6-labs-2020-lab11$ make server
python3 server.py 26099
listening on localhost port 26099
```

新启动一个终端，启动qemu后运行`nettests`命令进行测试，输出如下:

```
$ nettests
nettests running on port 26099
testing ping: OK
testing single-process pings: OK
testing multi-process pings: OK
testing DNS
DNS arecord for pdos.csail.mit.edu. is 128.52.129.126
DNS OK
all tests passed.
$
```

同时，服务端输出以下内容：

```
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
a message from xv6!
```

返回新启动的终端，输入`tcpdump -XXnr packets.pcap`命令，进行测试。输出如下：

```
hane7ad@DESKTOP-O1CAKP8:~/xv6-labs-2020-lab11$ tcpdump -XXnr packets.pcap
reading from file packets.pcap, link-type EN10MB (Ethernet)
07:58:30.992705 IP 10.0.2.15.2000 > 10.0.2.2.26099: UDP, length 19
        0x0000:  ffff ffff ffff 5254 0012 3456 0800 4500  ......RT..4V..E.
        0x0010:  002f 0000 0000 6411 3eae 0a00 020f 0a00  ./....d.>.......
        0x0020:  0202 07d0 65f3 001b 0000 6120 6d65 7373  ....e.....a.mess
        0x0030:  6167 6520 6672 6f6d 2078 7636 21         age.from.xv6!
07:58:30.993323 ARP, Request who-has 10.0.2.15 tell 10.0.2.2, length 28
        0x0000:  ffff ffff ffff 5255 0a00 0202 0806 0001  ......RU........
        0x0010:  0800 0604 0001 5255 0a00 0202 0a00 0202  ......RU........
        0x0020:  0000 0000 0000 0a00 020f                 ..........
07:58:30.993595 ARP, Reply 10.0.2.15 is-at 52:54:00:12:34:56, length 28
        0x0000:  ffff ffff ffff 5254 0012 3456 0806 0001  ......RT..4V....
        0x0010:  0800 0604 0002 5254 0012 3456 0a00 020f  ......RT..4V....
        0x0020:  5255 0a00 0202 0a00 0202                 RU........
07:58:30.993718 IP 10.0.2.2.26099 > 10.0.2.15.2000: UDP, length 17
        0x0000:  5254 0012 3456 5255 0a00 0202 0800 4500  RT..4VRU......E.
        0x0010:  002d 0000 0000 4011 62b0 0a00 0202 0a00  .-....@.b.......
        0x0020:  020f 65f3 07d0 0019 3216 7468 6973 2069  ..e.....2.this.i
        0x0030:  7320 7468 6520 686f 7374 21              s.the.host!
//这里仅展示部分
```

### 3. 注意事项和提示

使用 E1000 网络设备处理网络通信。对于 xv6 和 开发者所写驱动，E1000 像一个真正的硬件，连接到真正的以太网 LAN (local area network)。实际，和驱动通信的 E1000 是由` qemu `仿真的，E1000 连接的 LAN 也是由` qemu `仿真的。在仿真的 LAN 中，xv6 （"guest"） 的 IP 地址是 `10.0.2.15`，`qemu` 安排运行` qemu` 的计算机的 IP 地址是 `10.0.2.2`。当 xv6 使用 E1000 向 `10.0.2.2` 发一个 `packet`，`qemu `把这个` packet `传给运行` qemu` 的真实计算机（"host"）上的合适的应用。

使用 QEMU 的 "user-mode network stack" （[文档](https://wiki.qemu.org/Documentation/Networking#User_Networking_.28SLIRP.29])）。

`Makefile` 配置 QEMU 记录所有的传入和传出 `packet `到` lab `目录下的文件 `packets.pcap`。有助于检查 xv6 发送和接收的` packet `是否符合期待。显示记录的` packet`：

```shell
tcpdump -XXnr packets.pcap
```

文件` kernel/e1000.c `有 E1000 的初始化代码和发送/接收` packet `的空的函数，空函数需要在本实验完成。
`kernel/e1000_dev.h `有寄存器的定义， E1000 定义的和 Intel E1000 软件工程师手册描述的标志位。
`kernel/net.c` 和` kernel/net.h `有一个简单的网络栈，实现了 IP, UDP, ARP 协议。这些文件有灵活的数据结构代码用于保存` packet`，称为 `mbuf`。
`kernel/pci.c` 有代码用于在 xv6 启动时，在 PCI 总线上查找 E1000 卡。



为了测试实验的驱动，在一个窗口运行 `make server` ，在另一个窗口运行 `make qemu`，然后在 xv6 中运行 `nettests`。`nettests` 第一个测试用例尝试发送一个` UDP cket `给 `host OS`，发送给` host OS `上 `make server` 运行的程序。如果没有完成 lab，E1000 驱动不会真正的发送 `packet`，并且什么都不会发生。

完成 lab 之后，E1000 驱动将发送 `packet`，qemu 将` packet `传给 host 计算机，`make server` 能收到这个 packet，且会发送一个响应 `packet`，然后 E1000 驱动和 `nettests` 将收到响应 `packet`。然而，在 host 发送响应之前，它先发送一个 “ARP” 请求 `packet `给 xv6，查找 4848 位的以太网地址，期待 xv6 发回一个 ARP 响应。实验不需要考虑这个问题，`kernel/net.c` 负责处理。如果一切 OK，`nettests` 将打印 `testing ping: OK`,`make server` 将打印 `a message from xv6!`。

`tcpdump -XXnr packets.pcap` 因该产生起始如下的输出：

````bash
reading from file packets.pcap, link-type EN10MB (Ethernet)
15:27:40.861988 IP 10.0.2.15.2000 > 10.0.2.2.25603: UDP, length 19
        0x0000:  ffff ffff ffff 5254 0012 3456 0800 4500  ......RT..4V..E.
        0x0010:  002f 0000 0000 6411 3eae 0a00 020f 0a00  ./....d.>.......
        0x0020:  0202 07d0 6403 001b 0000 6120 6d65 7373  ....d.....a.mess
        0x0030:  6167 6520 6672 6f6d 2078 7636 21         age.from.xv6!
15:27:40.862370 ARP, Request who-has 10.0.2.15 tell 10.0.2.2, length 28
        0x0000:  ffff ffff ffff 5255 0a00 0202 0806 0001  ......RU........
        0x0010:  0800 0604 0001 5255 0a00 0202 0a00 0202  ......RU........
        0x0020:  0000 0000 0000 0a00 020f                 ..........
15:27:40.862844 ARP, Reply 10.0.2.15 is-at 52:54:00:12:34:56, length 28
        0x0000:  ffff ffff ffff 5254 0012 3456 0806 0001  ......RT..4V....
        0x0010:  0800 0604 0002 5254 0012 3456 0a00 020f  ......RT..4V....
        0x0020:  5255 0a00 0202 0a00 0202                 RU........
15:27:40.863036 IP 10.0.2.2.25603 > 10.0.2.15.2000: UDP, length 17
        0x0000:  5254 0012 3456 5255 0a00 0202 0800 4500  RT..4VRU......E.
        0x0010:  002d 0000 0000 4011 62b0 0a00 0202 0a00  .-....@.b.......
        0x0020:  020f 6403 07d0 0019 3406 7468 6973 2069  ..d.....4.this.i
        0x0030:  7320 7468 6520 686f 7374 21              s.the.host!

````

实验输出看起来有点不同，但应该包含："ARP, Request", "ARP, Reply", "UDP", "a.message.from.xv6" 和 "this.is.the.host"。

`nettests` 运行一些其他用例，最终是一个 DNS 请求，通过真正的互联网，发送到 Google 的一个 `name server`。确保代码通过所有测试用例，之后应该看到如下输出：

````bash
$ nettests
nettests running on port 25603
testing ping: OK
testing single-process pings: OK
testing multi-process pings: OK
testing DNS
DNS arecord for pdos.csail.mit.edu. is 128.52.129.126
DNS OK
all tests passed.
````

需要确保 `make grade` 通过实验代码。

## 二. 总实验结果

在目录下创建`time.txt`，并输入完成实验的小时数。在终端执行

```
 make grade
```

来对实验结果进行完全测试。

测试结果如下：

```
== Test running nettests ==
$ make qemu-gdb
(6.1s)
== Test   nettest: ping ==
  nettest: ping: OK
== Test   nettest: single process ==
  nettest: single process: OK
== Test   nettest: multi-process ==
  nettest: multi-process: OK
== Test   nettest: DNS ==
  nettest: DNS: OK
== Test time ==
time: OK
Score: 100/100
```

## 三.遇到的问题及解决方法

对概念不了解

本次实验内容较少，主要需要理解概念，代码按照guidance的hints一步步实现。

解决方法：多查阅源码以及网络博客